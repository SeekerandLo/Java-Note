## 几个点需要注意 

1. 在 BeanFactory 的创建过程中如何处理几种 BeanPostProcessor

2.  

## BeanFactory 如何创建: refresh()

- ### BeanFactory 的准备工作

1. [prepareRefresh() 刷新前的预处理](#prepareRefresh-刷新前的预处理)

2. [obtainFreshBeanFactory() 获取BeanFactory](#obtainFreshBeanFactory-获取BeanFactory)

3. [prepareBeanFactory(beanFactory) 准备BeanFactory](#prepareBeanFactory(beanFactory)-准备BeanFactory)

4. [postProcessBeanFactory(beanFactory) BeanFactory的后置处理](#postProcessBeanFactory(beanFactory)-BeanFactory-的后置处理)
 
- ### Bean 的准备

5. [invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactory的后置处理](#invokeBeanFactoryPostProcessors(beanFactory)-执行BeanFactoryPostProcessor-中的方法)

6. [registerBeanPostProcessors(beanFactory) 注册Bean的后置处理器](#registerBeanPostProcessors(beanFactory)-注册-Bean-的后置处理器)

7. [initMessageSource() 初始化MessageSource](#initMessageSource())

8. [initApplicationEventMulticaster 初始化事件派发器](#initApplicationEventMulticaster)

9. [onRefresh() 留给子类重写](#onRefresh()-留给子类重写)

10. [registerListeners() 检查listener并注册](#registerListeners()-检查listener并注册)

11. [finishBeanFactoryInitialization(beanFactory) 初始化Bean](#finishBeanFactoryInitialization(beanFactory)-初始化Bean)

12. [finishRefresh() 完成 BeanFactory 的初始化创建](#finishRefresh())
***

### prepareRefresh 刷新前的预处理
    准备刷新此 applicationContext

1. &emsp;initPropertySources()
    - 在上下文环境中初始化任何占位符属性源

2. &emsp;getEnvironment().validateRequiredProperties()
    - 验证所有标记为“必需”的属性是否可解析 

3. &emsp;this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners)  
    &emsp;this.earlyApplicationEvents = new LinkedHashSet<>()
    
    - 存储预刷新应用程序侦听器...
    
    - 允许收集早期的 ApplicationEvents，一旦多播可用，将发布...

### obtainFreshBeanFactory 获取BeanFactory
    告诉子类刷新内部 BeanFactory
1. &emsp;refreshBeanFactory()
    - 创建一个 BeanFactory   
    this.beanFactory = new DefaultListableBeanFactory()
    
    - 设置id  
    this.beanFactory.setSerializationId(getId())

2. &emsp;return getBeanFactory()
    - 返回创建的 BeanFactory    

### prepareBeanFactory(beanFactory) 准备BeanFactory
    BeanFactory 的准备工作
1. &emsp;设置好多属性，BeanFactory 的类加载器、支持表达式解析器

2. &emsp;添加部分 BeanPostProcessor 有 **ApplicationContextAwareProcessor**

3. &emsp;设置忽略依赖接口

4. &emsp;将一些接口设置成可自动装配的，可解析的
    
    - beanFactory.registerResolvableDependency(**BeanFactory.class**, beanFactory)  
	
    - beanFactory.registerResolvableDependency(**ResourceLoader.class**, this)
	
    - beanFactory.registerResolvableDependency
    (**ApplicationEventPublisher.class**, this)
	
    - beanFactory.registerResolvableDependency(**ApplicationContext.class**, this)

4. &emsp;将 ApplicationListeners 注册为检测内部 Bean 的早期后置处理器

    - beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

5. &emsp;检测 LoadTimeWearver，准备构建，如果找到的话

6. &emsp;注册默认的环境变量 Bean
    - 环境变量

    - 系统属性

### postProcessBeanFactory(beanFactory) BeanFactory 的后置处理
    允许上下文子类对 BeanFactory 进行后置处理

1. &emsp;提供方法给子类重写

### invokeBeanFactoryPostProcessors(beanFactory) 执行BeanFactoryPostProcessor 中的方法
    
    调用在上下文中注册为 Bean 的后置处理器

1. &emsp;PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())

    - 获取当前容器中的所有 BeanFactoryPostProcessor，BeanFactoryPostProcessor 有两类，一类是继承了它的 BeanDefinitionRegistryPostProcessor 接口，另一种是它自己，BeanDefinitionRegistryPostProcessor 在 Bean 的注册信息将要被调用时加载，可以修改当前上下文中 Bean 的注册信息，执行顺序： BeanDefinitionRegistryPostProcessor 在 BeanFactoryPostProcessor 之前

    - 先获取 BeanDefinitionRegistryPostProcessor，然后执行容器中的 BeanDefinitionRegistryPostProcessor 按照 优先级(实现 **PriorityOrdered** 接口)-> 顺序(实现 **Ordered** 接口) -> 普通(没有实现上述两个接口) 的顺序依次执行
    
    - 先获取 BeanFactoryPostProcessor，然后执行容器中的 BeanFactoryPostProcessor 按照 优先级(实现 **PriorityOrdered** 接口)-> 顺序(实现 **Ordered** 接口) -> 普通(没有实现上述两个接口) 的顺序依次执行


### registerBeanPostProcessors(beanFactory) 注册 Bean 的后置处理器
    注册拦截 Bean 的创建的后置处理器

1. &emsp;获取所有的 BeanPostProcessor，按照 优先级(实现 **PriorityOrdered** 接口)-> 顺序(实现 **Ordered** 接口) -> 普通(没有实现上述两个接口) 的顺序将这些注册到 BeanFactory 中

    - 在程序运行过程中还会增加一些 BeanPostProcessor 到 BeanFactory 中

### initMessageSource()
    为此上下文初始化信息源
1. &emsp;获取 BeanFactory，判断 BeanFactory 中是否存在 **messageSource** 的 Bean，如果存在，赋值给 this.messageSource，如果没有则创建一个 DelegatingMessageSource，注册到 BeanFactory 中

2. &emsp;如果以后需要用到 messageSource，可以自动注入这个 Bean，调用 getMessage(...) 方法

### initApplicationEventMulticaster()
    初始化事件派发器
1. &emsp;获取 BeanFactory，判断 BeanFactory 中是否存在 **applicationEventMulticaster**，如果存在，赋值给 this.applicationEventMulticaster，如果不存在，创建一个SimpleApplicationEventMulticaster，注册到 BeanFactory 中

### onRefresh() 留给子类重写
    初始化特定上下文子类中的其他特殊 Beans
1. &emsp;留给子类重写此方法

### registerListeners() 检查listener并注册
    检查 listener Bean 并注册它们

1. &emsp;首先注册静态指定的 listener

    - 获取全部的 applicationListener，添加到 this.applicationEventMulticaster 中去

2. &emsp;将每个监听器加入到事件派发器中

3. &emsp;派发 **之前** 添加的事件

### finishBeanFactoryInitialization(beanFactory) 初始化Bean
    初始化所有剩下的单实例 Bean

1. &emsp;beanFactory.preInstantiateSingletons()   
    初始化剩下的单实例 Bean
    
    - 获取容器中的所有 Bean，依次进行初始化和创建

    - 首先拿到 Bean 的定义信息，如果 Bean **不是抽象的**、**是单实例的**、**不是懒加载的**，则是要创建的 Bean
        - 判断 Bean 是否是 **FactoryBean**，有不同的创建过程

        - 如果是 **FactoryBean**，则调用 FactoryBean 中的 getObject

        - 如果不是 **FactoryBean**，则调用 [getBean(beanName)](#getBean(beanName))，创建对象

        - 所有的 Bean 都创建完成之后，判断 Bean 是否是 SmartInitializingSingleton ，如果是，则执行 afterSingletonsInstantiated() 方法

### finishRefresh() 
    最后一步，发布对应事件

- initLifecycleProcessor()  
    初始化和生命周期有关的后置处理器
  
- getLifecycleProcessor().onRefresh()  

- publishEvent(new ContextRefreshedEvent(this))

- LiveBeansView.registerApplicationContext(this)
  


***

### getBean(beanName)
调用 doGetBean()
- Object sharedInstance = getSingleton(beanName)  
首先获取缓存中的单实例 Bean

- 缓存中获取不到，则获取 BeanFactory，[父子容器相关，未记录]()

- markBeanAsCreated(beanName)   
  标记 Bean 已经被创建，防止多线程创建时创建的 Bean 不是单实例

- 获取 Bean 的定义信息  
  获取 Bean 的依赖信息 String[] dependsOn = mbd.getDependsOn()，如果依赖的 Bean 先使用 [getBean](#getBean(beanName)) 的方式获取依赖的Bean

- sharedInstance = getSingleton(beanName, ()->{})  
  开始创建单实例 Bean 

    - createBean(beanName, mbd, args) 👇

        - Object bean = resolveBeforeInstantiation(beanName, mbdToUse)  

                给 BeanPostProcessor 一个机会返回目标实例的代理对象
                
            是这个 **InstantiationAwareBeanPostProcessor**， 执行这个 BeanPostProcessor 的两个方法，如果
            applyBeanPostProcessors**BeforeInstantiation** 有返回值，则执行 applyBeanPostProcessors**AfterInitialization**

        - 如果 **InstantiationAwareBeanPostProcessor** 没有返回代理对象，则继续执行  
        
        - Object beanInstance = [doCreateBean(beanName, mbdToUse, args)](#doCreateBean)   
        创建 Bean

        - 返回


### doCreateBean

- instanceWrapper = [createBeanInstance(beanName, mbd, args)](#createBeanInstance)  
        创建 Bean 实例     

- applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)  
允许 BeanPostProcessor 修改合并的 Bean 定义
    
    - **MergedBeanDefinitionPostProcessor**

- **【Bean 赋值】** [populateBean(beanName, mbd, instanceWrapper)](#populateBean)  
为 Bean 赋值   

- **【Bean 初始化】** [initializeBean(beanName, exposedObject, mbd)](#initializeBean)

- **【获取单实例 Bean】** Object earlySingletonReference = getSingleton(beanName, false)

- registerDisposableBeanIfNecessary(beanName, bean, mbd)  
注册销毁方法


### createBeanInstance

- instantiateUsingFactoryMethod(beanName, mbd, args) 调用工厂方法或 Bean 的构造器 创建 Bean

### populateBean

- 赋值之前，拿到 **InstantiationAwareBeanPostProcessor**，执行postProcessAfterInstantiation 方法

- 继续执行，拿到 **InstantiationAwareBeanPostProcessor**，执行 postProcessProperties

- applyPropertyValues 应用 Bean 的 setter 方法 **赋值**

### initializeBean

-  invokeAwareMethods(beanName, bean)   
执行 Aware 接口的方法

- applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)
执行所有的后置处理器的在 Bean **初始化之前**的方法

- invokeInitMethods(beanName, wrappedBean, mbd)  
**执行初始化方法**
    - 判断 Bean 是否是实现了 **InitializingBean** 接口
    
    - 或者有自定义的初始化方法 

- applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)  
执行所有的后置处理器的在 Bean **初始化之后**的方法

- 返回 Bean
 