1. [冒泡排序](#冒泡排序)
2. [简单选择排序](#简单选择排序)
3. [直接插入排序](#直接插入排序)

## 排序

- 依据排序时是否将数据全部放置在内存中，将排序分为内排序和外排序，将内排序分为：**插入排序、交换排序、选择排序、归并排序**

- 按照算法复杂度将排序分为两类，简单算法：**冒泡排序、简单选择排序、直接插入排序**。改进算法：**希尔排序、堆排序、归并排序、快速排序**


## 排序算法的稳地性

- 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

## 冒泡排序
- 从后向前遍历，两两比较，能够将较小的数如同冒泡般上浮
    ```java
    public void bubbingSort(int[] array){
        int l = array.length;
        for (int i = 0; i < l; i++) {
            for (int j = l - 2; j >= i; j--) {
                if (array[j] > array[j + 1]) {
                    int temp;
                    temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                }
            }
        }
    }
    ```
- 上面的代码是标准的冒泡排序，还可以再优化，例如要排序的数组是
    ```java
    int[] array2 = {2, 1, 3, 4, 5, 6, 7, 8, 9, 10};
    ```
    上面的代码依旧会在第一次循环从最后一位开始冒泡，将第0位和第1位的数字排序，其实交换前两位数字后整个数组已经排序完成了，但是我们没有证据，还是会进入第二次循环，第三次循环...所以可以加一个标志位，当`i=1`时，由于后面的数据都没有再交换，说明数组已经有序了
    ```java
    private static void Improvement(int[] array) {
        boolean flag = true;
        for (int i = 0; i < array.length && flag; i++) {
            flag = false;
            for (int j = array.length - 2; j >= i; j--) {
                if (array[j] > array[j + 1]) {
                    int temp;
                    temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                    flag = true;
                }
            }
        }
    }
    ```
    ### 冒泡排序时间复杂度
    - 最好的情况，本身有序，只需判断`n-1`次就会突出，最差的情况，本身倒序，需要判断`1+2+3+...+n-1`，总共需要判断`(n-1)n/2`次及移动这么多次，所以总的时间复杂度为`O(n^2)`

## 简单选择排序
- 每次循环的目的都是找出最小的元素，并记录下最小元素的位置，循环完毕后判断最小元素的位置是不是此次循环的起始位置，如果不是交换最小元素与循环起始位置的元素
    ```java
    private static void selectSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int min = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[min]) {
                    min = j;
                }
            }
            if (min != i) {
                int temp;
                temp = array[i];
                array[i] = array[min];
                array[min] = temp;
            }
        }
    }
    ```
    ### 简单选择排序时间复杂度 
    - 简单选择排序交换数据的次数较少，如果需要，每次只交换一次数据，第i次排序需要比较`n-i`次，总比较次数为`n-1+n-2+...+1 = (n-1)n/2`，总的时间复杂度还是`O(n^2)`

## 直接插入排序
- 插入排序是将待排序的数组分为两部分，一部分是已经排序好的一部分是未排序的，每次从未排序部分拿出一个，与前面已经排序部分的最后一个元素比较，如果比它大，直接添加到已排序部分的最后，如果比它小，将已排序部分的最后一个元素右移一位，已排序部分扩大一位，然后判断待排序元素与已排序部分倒数第二位，如果比它小依然让倒数第二位右移...如果比它大就把待排序元素放在空出来的位置
    ```java 
    private static void directInsertSort(int[] array) {
        int temp;
        for (int i = 1; i < array.length; i++) {
            temp = array[i];
            while (i >= 1 && array[i - 1] > temp) {
                // 右移
                array[i] = array[i - 1];
                i--;
            }
            array[i] = temp;
        }
    }
    ```
- 插入排序的时间复杂度：最好的情况，本来就是顺序，O(n)，最坏的情况，本来是逆序，O(n2)

## 归并排序


## 快速排序