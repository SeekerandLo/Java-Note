1. [KMP](#KMP模式匹配算法)

## 串 
- 零个或多个字符组成的有限序列，也叫字符串

### 串的比较
- 字典序比较

### String

- Java 中的 String 是由 char[] 实现的

### KMP模式匹配算法

- KMP 算法是三位大牛的成果，思前想后真是让我浑身一震，对比暴力匹配，KMP简直了。

- KMP 的思想是通过已经匹配了的信息，保证 **i** 指针不回溯，让  **j** 指针不断的移动位置，让匹配串移动到最合适的位置，下面将目标串称为S，将要匹配串称为T

    ***
    **↓** **i=0**  
    **A** B A C B C D H I G K

    **A** B A D  
    **↑** **j=0**
    ***
    &emsp;↓ **i=1**   
    A **B** A C B C D H I G K

    A **B** A D  
    &emsp;↑ **j=1**
    ***
    &emsp;&emsp;↓ **i=2**  
    A B **A** C B C D H I G K

    A B **A** D    
    &emsp;&emsp;↑ **j=2**
    ***
    &emsp;&emsp;&emsp;↓ **i=3**  
    A B A **C** B C D H I G K

    A B A **D**    
    &emsp;&emsp;&emsp;↑(j) **j=3**
    ***
  此时，S[3] != T[3]，需要移动匹配串，如果是暴力匹配，会把 **i** 移动到 **1** 的位置，**j** 移动到 **0** 的位置然后重新开始，**但是** KMP 算法不会这么做，它是利用之前匹配的信息，只移动匹配串，让匹配串中的字符去跟目标串中的字符对应，直接移动到最**有效**的位置，如何理解有效？我现在无法形容，直白的表示，是移动 T 串，让 T 串中的一部分**再**与 S 串对应，先按照 KMP 的思路移动一次

    ***
    &emsp;&emsp;&emsp;↓ **i=3**                                
    A B A **C** B C D H I G K                                                                           
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;                
    A **B** A D    
    &emsp;↑ **j=1**
    ***
    将 j 移动到现在的位置, 为什么要移动到这里呢，从串上我们看出来，S[3] 位置前的 S[2] 与 T[1] 前的 T[0] 相等，**问题来了**，如何知道 S[3] 位置前的 S[2] 与 T[1] 前的 T[0] 相等呢？请看下面的代码    
    ```java
    T[2] = S[2];
    T[0] = T[2];
    T[0] = S[2];

    // T[0] = S[2] 是因为 T[0] = T[2]
    ```
    从 T 串自己的位置出发，我能知道自己身上的哪个位置和哪个位置相等吗，如果我知道，当需要移动时，就可以直接移动到理想位置  
    
    如果按照这个来移动，将 T[0] 与 S[2] 对应上，相当于下面的样子，和上面的式子是一样的。
    ***
    &emsp;&emsp;&emsp;↓ **i=3**                                
    A B A **C** B C D H I G K                                                                           
    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;                
    &emsp;&emsp;A **B** A D    
    &emsp;&emsp;&emsp;↑ **j=1**
    ***
    如果想不通，可以试试下面的思路：  
    
    此时，j=1。现在从匹配字符串的问题上转到了获取匹配串的哪个位置和哪个位置相等上，如果知道 T[m] 和 T[n] （m \< n）相等，当 S[i] != T[n+1] 时，那就试试 S[i] 与 T[m+1] 是否匹配（因为 T[m] = T[n]，既然已经走到了S[i] 与 T[n+1]的比较，那么S[i-1] 与 T[n] 已经匹配了，所有s[i-1]也等于T[m]）   

    上面是只有一个字符是相等的，如果在匹配串中有多个连续字符是相等的呢，会是什么情况？ 再看下面一个例子，当匹配到 5 的位置上时，S[5] != T[5]，这时需要移动 j 了，观察到 T[0]T[1] 与 T[3]T[4] 相同，于是将 j 移动到 2 的位置上，让 S[3]S[4] 与 T[0]T[1] 对应上，如下下图
    ***
    &emsp;&emsp;&emsp;&emsp;&emsp;↓ **i=5**                         
    A B C A B **C** D H I G K    

    A B C A B **D**  
    &emsp;&emsp;&emsp;&emsp;&emsp;↑ **j=5**
    ***
    &emsp;&emsp;&emsp;&emsp;&emsp;↓ **i=5**                         
    A B C A B **C** D H I G K    

    A B **C** A B D  
    &emsp;&emsp;↑ **j=2**
    ***
    这样可以得出一个规律，当移动匹配串时，只需移动 j 到**当前 j 位置之前的字符串中有多少个相同的前缀后缀字符**的位置上，比如上面 D 之前的字符串中前后缀相同的字符是 2 ，所以将 j 移动到 2 的位置上

- 代码实现 




