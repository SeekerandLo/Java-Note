1. [HashMapæºç åˆ†æ](#HashMap)
2. [HashMapæ‰©å®¹æ–¹æ³•]()
3. [HashMapå­˜å‚¨å…ƒç´ ]()



## å“ˆå¸Œè¡¨(å“ˆå¸Œæ¡¶)

- ç”¨äºæŸ¥æ‰¾ï¼Œå¦‚æœå¯ä»¥åˆ©ç”¨å…³é”®å­—ä¸éœ€è¦æ¯”è¾ƒå°±èƒ½è·å¾—ç›®æ ‡è®°å½•çš„å­˜å‚¨ä½ç½®ï¼Œè¿™å°±å‡ºç°äº†æ–°çš„å­˜å‚¨æŠ€æœ¯â€”â€”â€”â€”æ•£åˆ—æŠ€æœ¯ã€‚é‡‡ç”¨æ•£åˆ—æŠ€æœ¯å°†è®°å½•å­˜å‚¨åœ¨ä¸€å—è¿ç»­çš„å­˜å‚¨ç©ºé—´ä¸­ï¼Œè¿™ä¸ªç©ºé—´å°±æ˜¯å“ˆå¸Œè¡¨

- å“ˆå¸Œè¡¨æœ€é€‚åˆæŸ¥æ‰¾ä¸ç»™å®šå€¼æ˜¯å¦ç›¸ç­‰çš„é—®é¢˜ï¼Œä¸é€‚åˆæŸ¥æ‰¾èŒƒå›´å€¼

## HashMap

### å¼•è¨€
HashMap æ˜¯æ•°ç»„ä¸é“¾è¡¨çš„ç»“åˆï¼Œä¸»è¦ä» HashMap çš„æ‰©å®¹å’Œå­˜å‚¨æ¥å­¦ä¹ å®ƒï¼Œä¸‹é¢æ˜¯ HashMap ä¸­å®šä¹‰çš„å†…éƒ¨ç±»ä¸å˜é‡
```java
// ä¸€äº›å±æ€§

// HashMapä¸­çš„èŠ‚ç‚¹ï¼Œå®ç°äº†Mapæ¥å£ä¸­çš„å†…éƒ¨æ¥å£Enrtyï¼ŒEntryä¸­æ˜¯å¯¹èŠ‚ç‚¹çš„æ“ä½œï¼Œå¦‚getKeyï¼ŒgetValueç­‰ï¼Œå…·ä½“å¯çœ‹ä¸‹é¢
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key;
    V value;
    Node<K, V> next;

    Node(int hash, K key, V value, Node<K, V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    // ...
}

// ä¸€äº›è¾¹ç•Œå€¼

// é»˜è®¤åˆå§‹å®¹é‡ 16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
// æœ€å¤§å®¹é‡ 2^30
static final int MAXIMUM_CAPACITY = 1 << 30;
// é»˜è®¤åŠ è½½å› å­ 0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// æ ‘åŒ–çš„é˜ˆå€¼
static final int TREEIFY_THRESHOLD = 8;
// éæ ‘åŒ–çš„é˜ˆå€¼
static final int UNTREEIFY_THRESHOLD = 6;
// æœ€å°çš„æ ‘å®¹é‡
static final int MIN_TREEIFY_CAPACITY = 64;

// å®šä¹‰çš„å˜é‡

// å­˜å‚¨ç»“æ„
transient Node<K,V>[] table;
// å­˜å‚¨æ•°é‡
transient int size;
// ä¿®æ”¹æ¬¡æ•°ï¼Œfor fail-fast
transient int modCount; 
// é˜ˆå€¼ 
// The next size value at which to resize (capacity * load factor)
int threshold;
// åŠ è½½å› å­
final float loadFactor;
```

### HashMapçš„å­˜å‚¨è¿‡ç¨‹

- æ±‚ key çš„å“ˆå¸Œå€¼ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ­¤ä½ç½®æ˜¯å¦æœ‰å…ƒç´ 
- å¦‚æœæ²¡æœ‰å…ƒç´ ï¼Œå­˜å‚¨ï¼Œå¦‚æœæœ‰ï¼Œä»¥é“¾è¡¨çš„å½¢å¼å­˜åœ¨é“¾è¡¨æœ€å
- å¦‚æœé“¾è¡¨é•¿åº¦è¶…è¿‡äº†é˜ˆå€¼8ï¼Œå…ˆæŸ¥çœ‹æ•°ç»„çš„é•¿åº¦æ˜¯å¦è¶…è¿‡äº†64ï¼Œå¦‚æœæ²¡æœ‰è¶…è¿‡ï¼Œå…ˆæ‰©å®¹ï¼Œå¦‚æœè¶…è¿‡äº†ï¼Œå°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼Œé“¾è¡¨é•¿åº¦ä½äº6ï¼Œå°†çº¢é»‘æ ‘è½¬åŒ–ä¸ºé“¾è¡¨
- å¦‚æœèŠ‚ç‚¹å·²ç»å­˜åœ¨å°±æ›¿æ¢æ—§å€¼
- å¦‚æœæ¡¶æ»¡äº†ï¼Œéœ€è¦æ‰©å®¹ [ğŸ‘‰HashMapçš„æ‰©å®¹æ–¹æ³•](#HashMapçš„æ‰©å®¹æ–¹æ³•)

### HashMapçš„è¯»å–è¿‡ç¨‹

- å½“è°ƒç”¨get()æ–¹æ³•ï¼ŒHashMapä¼šä½¿ç”¨é”®å¯¹è±¡çš„hashcodeæ‰¾åˆ°bucketä½ç½®ï¼Œæ‰¾åˆ°bucketä½ç½®ä¹‹åï¼Œä¼šè°ƒç”¨keys.equals()æ–¹æ³•å»æ‰¾åˆ°é“¾è¡¨ä¸­æ­£ç¡®çš„èŠ‚ç‚¹ï¼Œæœ€ç»ˆæ‰¾åˆ°è¦æ‰¾çš„å€¼å¯¹è±¡ã€‚

### HashMapçš„æ‰©å®¹æ–¹æ³•

- ä¸ `ArrayList` ç­‰çº¯é¡ºåºå­˜å‚¨ç»“æ„çš„æ‰©å®¹æ–¹æ³•ä¸åŒï¼ŒHashMap çš„æ‰©å®¹æ¯”è¾ƒå¤æ‚ï¼Œä¸‹é¢æ¥è§‚æ‘©ä¸€ä¸‹ï¼Œé¦–å…ˆé˜…è¯» `resie()` æ–¹æ³•ä¸Šçš„æ³¨é‡Šï¼š
    > Initializes or doubles table size

    åˆå§‹åŒ–æˆ–è€…åŒå€ `table` çš„å®¹é‡
    >If null, allocates in accord with initial capacity target held in field threshold

    å¦‚æœ `table` æ˜¯nullï¼Œé‚£ä¹ˆæ ¹æ®å­—æ®µé˜ˆå€¼æ¥åˆ†é…åˆå§‹å®¹é‡
    >Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table

    å¦åˆ™ï¼Œå¦‚æœ `table` ä¸æ˜¯nullï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ä¸¤æ¬¡æ‰©å±•çš„å¹‚ï¼Œæ‰€ä»¥æ¯ä¸ªå®¹å™¨ (bin) ä¸­çš„å…ƒç´ è¦ä¹ˆä¿æŒç›¸åŒçš„ç´¢å¼•ï¼Œè¦ä¹ˆåœ¨æ–°è¡¨ä¸­ä»¥ä¸¤æ¬¡åç§»çš„å¹‚ç§»åŠ¨ã€‚  

- å°† `resize()` æ–¹æ³•ä¸­çš„åˆ¤æ–­ä»£ç å—ç¼©èµ·æ¥åå¯ä»¥çœ‹åˆ°å¦‚ä¸‹çš„ä»£ç ç»“æ„ï¼Œåˆå§‹åŒ–ä¸€äº›å˜é‡ï¼Œç„¶åè¿›è¡Œåˆ¤æ–­ï¼Œç»è¿‡å‡ æ­¥ä¹‹ååˆ›å»ºæ–°çš„æ•°ç»„
    ```java
    final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        // ç¬¬ä¸€å—
        if (oldCap > 0) {...}
        else if (oldThr > 0) {...} // initial capacity was placed in threshold
        else {...}             // zero initial threshold signifies using defaults
        // ç¬¬äºŒå—    
        if (newThr == 0) {...}

        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        // ç¬¬ä¸‰å—
        if (oldTab != null) {...}
        
        return newTab;
    }
    ```
- ç¬¬ä¸€ä¸ªä»£ç å—
    ```java
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                    oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               
        // ç¬¬ä¸€æ¬¡æ’å…¥æ—¶ä¼šè°ƒç”¨çš„
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    ```
- ç¬¬äºŒä¸ªä»£ç å—
    ```java
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    ```