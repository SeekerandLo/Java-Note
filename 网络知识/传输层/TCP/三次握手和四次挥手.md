## 三次握手和四次挥手

## 三次握手

## 四次挥手

&emsp;&emsp;任何一端在发送完数据之后都可以结束连接，下面将主动结束的一方称为 A 端，将后结束的一方称为 B 端

### 四次挥手过程

&emsp;&emsp;老生常谈了💂‍

- 第一次：A 的应用进程先发送连接释放报文段，并停止再发送数据，主动关闭 TCP 连接，A 把连接释放报文段首部的终止位置 FIN 置1，序列号为 seq = u，等于前面发送的数据的最后一个字节的序号加 1，这时 A 进入 `FIN-WAIT-1` 阶段，等待 B 的确认。

- 第二次：B 收到 A 发送的连接释放报文后即发送确认报文，确认号是 u+1，自己的序列号是 v，v 是上次发送数据的最后一个字节的序列号加1，然后 B 进入 `CLOSE-WAIT` 阶段。这时 A 到 B 方向上连接就释放了，这时的 TCP 连接处于半关闭状态。  

    A 收到 B 发送的确认后，进入 `FIN-WAIT-2` 阶段，等待 B 发送连接释放请求

- 第三次：B 向 A 的发送数据也发送完毕了，B 就向 A 发送连接释放报文，FIN = 1，假设序列号 seq = w(可能在连接释放前，又发送了一些数据)，确认号还必须是 ack = u + 1(因为❓)。这时 B 进入 `LAST-ACK` 阶段，等待 A 的确认。

- 第四次：A 在收到 B 的连接释放请求之后，必须对 B 再发送确认，确认报文段 ACK = 1，确认号 ack = w+1，序列号 seq = u+1，然后进入 `TIME-WAIT` 阶段，然后等待**时间等待计时器**设置的时间 2MSL 后，A 进入 `CLOSED` 阶段。  

    B在收到确认之后，进入 `CLOSED` 阶段

### 为什么 A 端在 TIME_WAIT 阶段必须等待 2MSL 的时间呢

&emsp;&emsp;有两个原因

- 保证 A 端发送的最后一个 ACK 报文段到达 B 端。这个报文段可能丢失，因此使处于 LAST—ACK 阶段的 B 端收不到确认，B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，再次发送确认，重启 2MSL 计时器，最后 A 和 B 都正常进入 CLOSED 阶段。如果 A 在 TIME—WAIT 阶段不等待一段时间，而在发送完 ACK 报文段后立即进入 CLOSED 阶段，那么就无法收到 B 发送的 FIN+ACK 的重传，导致 B 无法进入 CLOSED 阶段

- 防止已失效的连接报文段出现在本连接中。A在发送完最后一个 ACK 报文段后，再经过 2MSL 时间，就可以使本连接持续时间内产生的所有报文段在网络中消失，这样就可以使下一个连接中不会出现旧的连接请求报文段
