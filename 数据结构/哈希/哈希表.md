1. [HashMap源码分析](#HashMap)

## 哈希表

- 用于查找，如果可以利用关键字不需要比较就能获得目标记录的存储位置，这就出现了新的存储技术————散列技术。散列技术是在记录的存储位置和它的关键字之间建立一个确定的函数f，使得每个关键字的key都能通过f(key)得到相应位置，把函数f称为散列函数，也叫哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这个空间就是哈希表

- 哈希表最适合查找与给定值是否相等的问题，不适合查找范围值

### 哈希函数的构造方法

1. 直接定址法  
    f(key) = a*key+b 以key的线性函数为散列地址，简单均匀，且不会冲突，需要实现知道key的分布情况，适合查找表较小且连续的情况

2. 数字分析法    
    如果key是数字的话，提前key的部分进行处理，设计一个函数

3. 平方取中法

4. 折叠法

5. 除留余数法
    f(key) = key mod p(p<=m) mod是取模求余数

6. 随机数法

## HashMap
```java
// 一些属性

// HashMap中的节点，实现了Map接口中的内部接口Enrty，Entry中是对节点的操作，如getKey，getValue等，具体可看下面
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key;
    V value;
    Node<K, V> next;

    Node(int hash, K key, V value, Node<K, V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    // ...
}

// 一些边界值

// 默认初始容量 16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
// 最大容量 2^30
static final int MAXIMUM_CAPACITY = 1 << 30;
// 默认加载因子 0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 树化的阈值
static final int TREEIFY_THRESHOLD = 8;
// 非树化的阈值
static final int UNTREEIFY_THRESHOLD = 6;
// 最小的树容量
static final int MIN_TREEIFY_CAPACITY = 64;

// 定义的变量

// 存储结构
transient Node<K,V>[] table;
// 存储数量
transient int size;
// 修改次数
transient int modCount;
// 阈值 
// The next size value at which to resize (capacity * load factor)
int threshold;
// 加载因子
final float loadFactor;
```

### 引言

- HashMap 是**数组与链表的结合**，数组中存放着节点，节点是单向链表的组成元素，下面的 Node 是 HashMap 中的节点类，它实现了 Map 接口中的内部接口 Entry，Entry 接口中定义了操作，有`getKey()`，`getValue()`，`setValue()`，`equals()`，`hasCode()` 及四个比较方法———[留坑]()，如下  
    1. comparingByKey()
    2. comparingByValue()
    3. comparingByKey(Comparator<? super K> cmp)
    4. comparingByValue(Comparator<? super V> cmp)

- HashMap 是依靠**数组**来横向存储，所以需要考虑扩容的问题，HashMap 中定义了阈值来控制扩容，如果超过了阈值会扩容数组，**阈值 = 容量 * 加载因子**，[👉扩容方法](#HashMap的扩容方法)。在初始化 HashMap 时不会对其里面的存储数组进行初始化，对存储数组的初始化是在第一次插入数据的时候，首先判断数组是不是 null 和容量，然后调用[扩容方法](#HashMap的扩容方法)初始化数组
    
### HashMap的扩容方法

- 与 `ArrayList` 等纯顺序存储结构的扩容方法不同，HashMap 的扩容比较复杂，下面来观摩一下，首先阅读 `resie()` 方法上的注释：
    > Initializes or doubles table size

    初始化或者双倍 `table` 的容量
    >If null, allocates in accord with initial capacity target held in field threshold

    如果 `table` 是null，那么根据字段阈值来分配初始容量
    >Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table

    否则，如果 `table` 不是null，因为我们使用的是两次扩展的幂，所以每个容器 (bin) 中的元素要么保持相同的索引，要么在新表中以两次偏移的幂移动。  

    读完注释后对该方法有了初步的了解，是初始化 `table` 容量，要么就是容量*2，下面来走一遍代码

- 将 `resize()` 方法中的判断代码块缩起来后可以看到如下的算法结构，首先创建了一个 `oldTab`，把 `table` 赋给它，然后获取它的 `cap`，第一次插入时`table`都是 null，所以 `oldCap` 是0。创建 `oldThr`，接收现在的阈值，`HashMap` 中定义的 `threshold` 初始化的时间也不一样，如果创建 `HashMap` 对象时没有指定的容量，那么阈值也是再第一插入时初始化的，如果指定了容量，会在初始化对象时初始化。

    然后[一顿操作](#一顿操作)，暂且不提...

    后面的代码就很明显了，使用 `newCap` 初始化新数组，然后赋给老数组`table`，再返回新数组
    ```java
    final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        // 第一块
        if (oldCap > 0) {...}
        else if (oldThr > 0) {...} // initial capacity was placed in threshold
        else {...}             // zero initial threshold signifies using defaults
        // 第二块    
        if (newThr == 0) {...}

        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        // 第三块
        if (oldTab != null) {...}
        
        return newTab;
    }
    ```
- [点击查看一顿操作](#一顿操作)，在看了第一个代码块与第二个代码块后，新的容量和阈值已经设置完毕，然后创建 `newTab`，再把 `newTab` 赋给 `table`

- 第三个代码块是 `oldTab` 是否为 null 的判断，如果不是 null，那么在**扩容完成后要进行的操作**




    
### 一顿操作 
- 第一个代码块
    ```java
    if (oldCap > 0) {
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                    oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               
        // 第一次插入时会调用的
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    ```
    从第一块代码开始拆解 `if` 代码块，第一个判断，判断现在 `table` 的长度是不是大于0，如果是第一次插入会是0，否则就会进入到该代码块，那么我们进去。
    
    首先礼貌的判断现在的数组容量是不是比最大容量还大于等于了，**如果是**就不扩容了，让阈值等于Integr的最大值然后直接返回 `oldTab`，如果一个数组的长度已经接近 2^30 次已经是很大了。**如果不是**那么新的容量等于旧容量的2倍，同时判断新容量是不是超过容量限制，并且也判断旧的容量是否比默认的大，这里[留坑，容量会变小吗]()，**如果正常**新的阈值等于旧的阈值的2倍，然后扩容完成了
    
- 第一个 `if` 代码块通过容量是否大于0来进入，那如果 `oldCap` 小于0，或者等于0呢，以第一次插入时为例，`oldCap` 和 `oldThr` 都是0，那么会全部初始化新的容量和阈值即进入最后的 `else`。

    如果 `oldCap` 小于或者等于0，来到第二个 `if` 判断 `oldThr` 是否大于0，如果它大于0，**新的数组容量就等于旧的阈值**，替换了上面 `oldCap` 的2倍，[意义是什么]()，进入到这个判断的情况有，已经插入了元素，当容量到达了第一次可以 `resize()` 时，会进入。

- 第二个代码块
    ```java
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    ```
    第二个代码块判断 `newThr == 0`，如果想这个条件成立，看上面的代码发现，只能是`oldThr = 0`才能做到，问题来了[什么时threshold会是0]()
        
    先看里面代码，还是创建了一个阈值ft，然后判断ft是否越过了界限，如果没有就决定是它了，新的阈值就是ft

- 第三个代码块