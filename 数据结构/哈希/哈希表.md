1. [HashMap源码分析](#HashMap)

## 哈希表

- 用于查找，如果可以利用关键字不需要比较就能获得目标记录的存储位置，这就出现了新的存储技术————散列技术。散列技术是在记录的存储位置和它的关键字之间建立一个确定的函数f，使得每个关键字的key都能通过f(key)得到相应位置，把函数f称为散列函数，也叫哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这个空间就是哈希表

- 哈希表最适合查找与给定值是否相等的问题，不适合查找范围值

### 哈希函数的构造方法

1. 直接定址法  
    f(key) = a*key+b 以key的线性函数为散列地址，简单均匀，且不会冲突，需要实现知道key的分布情况，适合查找表较小且连续的情况

2. 数字分析法    
    如果key是数字的话，提前key的部分进行处理，设计一个函数

3. 平方取中法

4. 折叠法

5. 除留余数法
    f(key) = key mod p(p<=m) mod是取模求余数

6. 随机数法

### HashMap

- HashMap 是**数组与链表的结合**，数组中存放着节点，节点是单向链表的组成元素，下面的 Node 是 HashMap 中的节点类，实现了 Map 接口中的内部接口 Entry  
    ```java
    static class Node<K, V> implements Map.Entry<K, V> {
        final int hash;
        final K key;
        V value;
        Node<K, V> next;

        Node(int hash, K key, V value, Node<K, V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        // ...
    }
    ```

    Entry 接口中定义了`getKey()`，`getValue()`，`setValue()`，`equals()`，`hasCode()` 及四个比较方法--[留坑]()，如下  
    1.   comparingByKey()
    2.   comparingByValue()
    3.   comparingByKey(Comparator<? super K> cmp)
    4.   comparingByValue(Comparator<? super V> cmp)

- 因为依靠数组来横向存储，所以需要考虑扩容的问题，HashMap 中定义了加载因子和容量来控制扩容，下面除了加载因子和容量还有几个阈值，是转换存储结构时会用到的
    ```java
    // 默认初始容量 16
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
    // 最大容量 2^30
    static final int MAXIMUM_CAPACITY = 1 << 30;
    // 默认加载因子 0.75
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 树化的阈值
    static final int TREEIFY_THRESHOLD = 8;
    // 非树化的阈值
    static final int UNTREEIFY_THRESHOLD = 6;
    // 最小的树容量
    static final int MIN_TREEIFY_CAPACITY = 64;
    ```
- HashMap 中的存储结构是数组，创建 HashMap 时并不会对数组进行操作，数组的扩容是在第一次插入时完成的，第一次插入时会由于 table 的长度是0，进行初始化 table 数组，容量为上面的默认初始容量`16`，阈值为`12` (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR)
    ```java
    // 存储结构
    transient Node<K,V>[] table;
    // 存储数量
    transient int size;
    // 修改次数
    transient int modCount;
    // 阈值 
    // The next size value at which to resize (capacity * load factor)
    int threshold;
    // 加载因子
    final float loadFactor;
    ```
