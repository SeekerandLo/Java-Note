1. [栈](#栈)
    - [栈的定义](#栈的定义)
    - [Vector](#Vector)
    - [Stack](#Stack)
    - [两栈共享空间](#两栈共享空间)
    - [栈的链式存储](#栈的链式存储)
    - [链栈和顺序栈如何选择](#链栈和顺序栈如何选择)
2. [队列](#队列)
    - [队列的定义](#队列的定义)
    - [Queue](#Queue)



## 栈
### 栈的定义
- 首先是一个线性表，将操作插入和删除的一端称为栈顶，将另一端称为栈底，是一种**先进后出**的结构，或称为后进先出(Last in First out)(LIFO)

### Vector
- Vector 是矢量队列，继承自AbstractList，实现了List，是一个队列，实现了增加删除等功能，还实现了 RandomAcces 接口，支持快速随机访问，底层使用的是动态数组，实现了 Clonable 接口和序列化接口
- Vector的添加元素和移除元素的方法，Stack 的压栈和出栈使用它们，扩容的办法与线性表的顺序存储类似，可去[👉线性表](https://github.com/SeekerandLo/Java-Note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8.md)查看
```java
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}


// elementCount 该线性表中元素的个数
// elementData 该线性表的实现数组
public synchorized void removeElementAt(int index){
    if(index >= elementCount){
        throw new ArrayIndexOutofBoundException(index + " >= " +
                    elementCount);
    }else if(index < 0){
        throw new ArrayIndexOutOfBoundsException(); 
    }

    int j = elementCount - index - 1;
    // 如果j = 0，代表是出栈操作

    // 如果j > 0，代表是删除其他位置的元素，理由数组复制
    if (j > 0) {
        System.arraycopy(elementData, index + 1, elementData, index, j);
    }

    elementCount--;
    elementData[elementCount] = null; // 让gc去处理
}
```

### Stack
- Java 中的 Stack 继承自 Vector 类，主要的实现方法在 Vector 类中，Vector 使用数组作为基础
- 使用的 Vector 中方法
```java
public E push(E e) {
    addElement(e);
    return e;
}

public E pop() {
    E obj;
    int len = size();
    obj = peek();
    removeElementAt(len - 1);
    return obj;
}

/**
    * 查看栈顶的对象而不移除
    *
    * @return
    */
public E peek() {
    int len = size();
    if (len == 0) {
        throw new EmptyStackException();
    }
    // 返回栈定元素，即 return elementData[index]
    return elementAt(len - 1);
}
```

### 两栈共享空间
- 思路：将一个数组分成两个空间，作为两个栈，将一个栈的栈底定为数组的**首位**，另一个栈的栈底为数组的**末尾**，添加元素时，两个栈的栈顶指针不断的向数组的中间移动，当**第一个栈的栈顶 +1 == 第二个栈的栈顶**时，数组满
- 用处：使用双栈通常用在两个组是互补的情况下，当一个栈在增加时，另一个在减小，否则如果两个栈都在增加，很快双栈就会占满，用于相同数据类型，否则会更复杂
```java
public class DoubleStack<E> extends Stack<E> {

    private Object[] elementData;

    /**
     * 两个index，栈顶指针
     * indexO 一栈
     * indexT 二栈
     */
    private int indexO = -1;
    private int indexT;

    /**
     * 数组容量
     */
    private int capacity;

    private int elementCount;

    public DoubleStack() {
        this(10);
    }

    public DoubleStack(int initialCapacity) {
        this.elementData = new Object[initialCapacity];
        this.indexT = this.capacity = initialCapacity;
    }

    /**
     * @param e        插入元素
     * @param stackNum 往哪个栈中插入
     */
    public void push(E e, int stackNum) {
        if (indexO + 1 == indexT) {
            throw new FillDoubleStackException("栈满了");
        }
        if (stackNum == 1) {
            indexO++;
            elementData[indexO] = e;
        } else if (stackNum == 2) {
            indexT--;
            elementData[indexT] = e;
        } else {
            throw new InvalidStackNumException();
        }
    }

    public void pop(int stackNum) {
        if (stackNum == 1) {
            if (indexO == -1) {
                throw new EmptyStackException();
            } else {
                elementData[indexO] = null;
                indexO--;
            }
        } else if (stackNum == 2) {
            if (indexT == capacity) {
                throw new EmptyStackException();
            } else {
                elementData[indexT] = null;
                indexT--;
            }
        } else {
            throw new InvalidStackNumException();
        }
    }

    /**
     * 查看栈顶元素
     *
     * @param stackNum 栈号
     * @return 元素
     */
    public E peek(int stackNum) {
        if (stackNum == 1) {
            if (indexO == -1) {
                throw new EmptyStackException();
            } else {
                return (E) elementData[indexO];
            }
        } else if (stackNum == 2) {
            if (indexT == capacity) {
                throw new EmptyStackException();
            } else {
                return (E) elementData[indexT];
            }
        } else {
            throw new InvalidStackNumException();
        }
    }
}
```

### 栈的链式存储

### 链栈和顺序栈如何选择
> 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，最后用链栈，如果变化在可控范围内，最好用顺序栈

### 栈的作用
- 递归：每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出

- 四则运算表达式求值
    - (逆波兰)后缀表示法定义：

## 队列
### 队列的定义
- 队列是只允许在一端操作插入，另一端操作删除的线性表
- 先进先出的线性表，FIFO(First In First Out)，允许插入的一端叫队尾，删除的一端是队头
### Queue
- Queue 接口的注释
> Queue是一个用来保存数据的集合，除了 Collection 接口实现的收集操作外，队列提供了额外的插入，提取，检查操作，这些方法有两种形式：一种是如果操作失败则抛出异常，一种是返回一个特殊的值，比如null，比如false，取决于什么操作。后一种形式的插入操作专门设计用于容量受限的情况设计的，大多数实现中，插入不会失败。

> Queue是典型的但不是必要的，规定里面的元素遵循 FIFO 的原则，有例外就是 priority queues(优先队列，根据比较器或者元素的自然顺序)，以及 LIFO 队列(后进先出队列)

> 无论遵循什么，要移除队列头部的元素都要使用 remove() 或者 poll() 方法，在 FIFO 队列中，所有新插入的元素都要插入的队列的尾部，其他队列可能使用不同类型的安置规则，每个队列的实现必须指定其排队顺序

> 

- Queue 中定义的方法
```java
// 截取于Queue接口的注释部分
<tr>
   <td><b>Insert</b></td>
   <td>{@link Queue#add add(e)}</td>
   <td>{@link Queue#offer offer(e)}</td>
 </tr>
 <tr>
   <td><b>Remove</b></td>
   <td>{@link Queue#remove remove()}</td>
   <td>{@link Queue#poll poll()}</td>
 </tr>
 <tr>
   <td><b>Examine</b></td>
   <td>{@link Queue#element element()}</td>
   <td>{@link Queue#peek peek()}</td>
 </tr>
```
- Queue 接口在 java 种与 set，list 平级，都继承了 Collection 接口。继承了 Queue 的接口和抽象类有
```
I: BlockingQueue // 阻塞队列

I: Deque // 双端队列，这里先不考虑

A: AbstractQueue // 非阻塞队列

```