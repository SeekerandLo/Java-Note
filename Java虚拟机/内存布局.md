### JVM 内存布局

### 1. 堆区(Heap)

```json
"Heap":{
    "name":"堆区",
    "Young":{
        "name":"新生代",
        "Eden":{ "name":"eden" },
        "Survivor":[{ "name":"S0" }, { "name":"S1" }]
    },
    "Old":{ "name":"老年代" }
}
```
- **堆存储着几乎所有实例对象，由垃圾回收器自动回收**

- 堆分为两大块：**新生代** 和 **老年代**
    - 新生代：对象产生之初位于新生代

    - 老年代：对象在经过一段时间后进入老年代

- JVM 只有一个堆区被各子线程共享，存储几乎所有实例对象，

#### 新生代

- 新生代分为 **Eden 区**和 **Survivor 区**，**Survivor 区有两个，分为 S0 和 S1 两个内存空间**

- 绝大部分对象在 Eden 区生成，当 Eden 区填充满后，会触发 Young Garage Collection（YGC）。垃圾回收时，在 Eden 区实现清除策略，**没有被引用的对象直接回收**。依然存活的对象被移送到 Survivor 区


### 2. 元空间(Metaspace)


### 3. 虚拟机栈(JVM stack)

- JVM 中虚拟机栈是描述 Java 方法执行的内存区域，**它是线程私有的**

#### 栈帧

- 栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程，在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。栈帧就是栈中的元素。

- 栈帧包括局部**变量表，操作栈，动态连接，方法返回地址**等

- **局部变量表**：局部变量表存储的方法参数和局部变量

- **操作栈**：操作栈是一个初始状态为空的桶式结构栈，在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM 的执行引擎式基于栈的执行引擎，其中的栈指的是操作栈

- **动态连接**：每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程动态连接

- **方法返回地址**：

### 4. 本地方法栈(Native Method Stack)

- 本地方法栈在JVM内存布局中，也是**线程对象私有**的，虚拟机栈主内，本地方法栈主外。本地方法栈为 Native 方法服务

### 5. 程序计数器(Program Counter Register)

- **每个线程**在创建之后后会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号计数器