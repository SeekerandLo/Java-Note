## 垃圾回收
&emsp;&emsp;垃圾回收的主要目的是清除不再使用的对象，自动释放缓存

- GC 是如何判断对象是否可以回收呢？
    
    - 为了判断对象存活，JVM 引入了 GC Roots，如果一个对象与 GC Roots 之间没有直接或间接的引用关系，比如某个失去任何引用的对象，或者两个互相环岛状循环引用的对象等，判决这些对象“死缓”，是可以被回收的。

    - 什么样的对象可以作为 GC Roots，比如：类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象等 

### 一些概念

- YGC 新生代的垃圾回收，新生代包含 Eden 和两个 Survivor

- FGC 老年代的垃圾回收

- Eden 堆内存中新生代中的一个区域

- Survivor 堆内存中新生代中的一个区域，有两个 Survivor

## 垃圾回收算法


### 标记清除算法

- 从每个 GC Roots 出发，依次标记有引用关系的对象，最后将没有被标记的对象清除

- 但是这种算法会带来大量的空间碎片，导致需要分配一个较大的连续空间时容易触发 FGC

- **什么时候会导致 FGC？**

    - 当老年代放不下对象后触发 FGC
    
- **再问，什么时候会触发 YGC**    

    - 当 Eden 区装填满后会触发 YGC



### 标记整理算法(Mark-Copy)

- 从 GC Roots 出发标记存活的对象，然后将存活对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片的问题

- 为了能够**并行**的标记和整理，将空间分为两块，每次只激活其中一块，垃圾回收时只需把存活的对象**复制**到另一块未激活空间上，将未激活的标记为已经激活，将已激活的标记为未激活，然后清除原空间中的原对象。

- 每次只使用 Eden 和 一块 Survivor 区，减少了内存空间的浪费

## 垃圾回收器

### Serial

- 一个主要应用于 YGC 的垃圾回收器，采用串行单线程的方式完成 GC 任务


### CMS(Concurrent Mark Sweep Collector)

- 一个回收停顿时间比较短，目前常用的垃圾回收器

- ... TODO

- 采用**标记清除**算法


### G1(JDK 7之后)(Garbage-First Garbage Collector)

- 和 CMS 相比，具备压缩功能，避免碎片问题