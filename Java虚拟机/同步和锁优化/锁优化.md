## 锁优化

### 自旋锁

&emsp;&emsp;互斥同步对性能影响最大的就是阻塞，其中挂起线程和唤醒线程需要耗费资源，给并发性能带来很大的压力。虚拟机开发团队发现，许多互斥时，对资源的锁定时间很少，这么短的时间没必要挂起线程，所以，能不能让后来的线程等待一会，看前面执行的线程能否释放资源，为了让线程等待，只需要让线程执行一个**忙循环(自旋)**，这就是自旋锁。

### 自适应自旋

&emsp;&emsp;自选本身虽然避免了线程挂起唤醒的开销，但是还是耗费处理器的资源，因此如果资源真的占用时间很短，自旋锁的效率就很高，但是如果资源一直不释放，自选锁就不合适。所以自选规定了次数，如果自旋超过了次数仍然没有获得锁，就挂起线程。默认是10次，可以使用参数 `-XX:PreBlockSpin` 来更改。  

&emsp;&emsp;JDK 1.6 引入了自适应自旋锁，自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。



### 锁消除

&emsp;&emsp;锁消除指虚拟机即时编译器在执行时，对一些代码同步，检测到不可能存在共享数据竞争时就将锁清除掉。 

&emsp;&emsp;锁消除的主要判定依据来源于**逃逸分析**的数据支持，如果判断在一段代码上，堆上的所有数据不会逃逸出去而被其他线程访问到，就可以把它们当成栈上数据对待。认为是线程私有的，就不需要加锁了。

### 锁粗化

&emsp;&emsp;原则上，在使用锁的时候，都尽量要求锁的范围要小，这样其他线程也能快速的获取资源。但是如果一系列操作频繁的对一个对象进行加锁，释放锁，频繁的互斥同步操作也会导致不必要的开销。

&emsp;&emsp;

### 轻量级锁
&emsp;&emsp;


### 偏向锁