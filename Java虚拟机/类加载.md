## 类加载

- 在 Java 代码中，类型的 **加载**、**连接** 与 **初始化** 过程都在 **程序运行期间** 完成

- 提供了更大的灵活性，增加了更多的可能性

### Java 虚拟机与程序的生命周期

在如下的几种情况，Java 虚拟机将结束生命周期
- 执行了 `System.exit()` 方法

- 程序正常执行结束

- 程序在执行过程中遇到了异常或错误而异常终止虚拟机

- 由于操作系统出现错误导致虚拟机进程终止

### 类的加载、连接、初始化

从磁盘到内存的过程

- 加载：查找并加载类的二进制数据

- 连接：
    - 验证：确保被加载类的正确性

    - 准备：为类的 **静态变量** 分配内存，并将其初始化为 **默认值**
        ```java
        public class Test{
            private static int a = 1;
        }
        ```
       int 类型的默认值 0
    - 解析：把类中的 **符号引用** 转化为 **直接引用**

- **初始化：为类的静态变量赋予正确的初始值**
    ```java
    // 将上面的 a 赋值 1
    ```
<!-- TODO 画个图 -->
```java
|—— —— ——|    |—— —— —— —— ——|
|        | -> |  |—— —— ——|  |
|—— —— ——|    |  |        |  |        
              |  |—— —— ——|  |
              |      |       |
              |      ↓       |
              |  |—— —— ——|  |
              |  |        |  | 
              |  |—— —— ——|  | 
              |      |       |
              |      ↓       |
              |  |—— —— ——|  |
              |  |        |  |    |—— —— ——|              
              |  |—— —— ——|  | -> |        |
              |—— —— —— —— ——|    |—— —— ——|                
```

- Java 对类的使用方式分为两种
  
    - [主动使用](#主动使用)有七种

    - [被动使用](#被动使用)

- 所有的 Java 虚拟机实现必须在每个类或接口被 Java 程序 **首次主动使用** 时才 **初始化** 它们

### 主动使用

- **创建类的实例**

- **访问某个类或者接口的静态变量，或者对该静态变量赋值**
    ```java
    /**
     * ✨对于静态字段来说，只有直接定义了该字段的类才会被初始化
     * ✨当一个类在初始化时，要求其父类全部已经初始化完毕
     */
    class Parent {
        public static String str = "hello Parent";
        static {
            System.out.println("Parent static");
        }
    }

    class Child extends Parent {
        public static String str2 = "hello Child";
        static {
            System.out.println("Child static");
        }
    }

    public class StaticClassTest {
        public static void main(String[] args) {
            System.out.println(Child.str);
        }
    }
    // 结果
    // Parent static
    // hello Parent
    
    // 可能会疑问，为什么没有输出 Child 中的 static 代码块呢
    // 因为，通过 Child 访问 Parent 中的 str，只访问了 Parent，所以初始化了 Parent 类，加载类中的静态代码块
    ```

    ```java
    // 将上述代码中的主方法中改为下面
    public class StaticClassTest {
        public static void main(String[] args) {
            System.out.println(Child.str2);
        }
    }

    // 结果
    // Parent static
    // Child static
    // hello Child

    // 此时是访问了 Child 类中的静态变量，加载 Child 时先加载其父类，运行父类的静态代码块，
    // 加载完毕后再加载 Child 类中的静态代码块，最后输出
    ```


- **调用类的静态方法**

- **反射 如 Class.forName("com.liy.Test");**

- **初始化一个类的子类时**

- **Java 虚拟机启动时被标明为启动类的类（Java Test) 如包含了 main 方法**

- JDK1.7 提供的动态语言支持，java.lang.invoke.MethodHandle 实例的解析结果 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic` **句柄对应的类没有初始化时则初始化**

### 被动使用
除了上述 **7** 种情况外，**其他都是被动使用**，都不会导致类的 **初始化**(三个步骤中的第三个)

### 类的使用和卸载
- 使用

- 卸载：从内存中销毁掉

## 类的加载

- 类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在**运行时数据区**的**方法区**内，然后在内存中创建一个 java.lang.Class 对象（规范并未说明 Class 对象位于哪里，HotSpot 虚拟机将其放在了方法区中）  
 [✨用来封装类在方法区内的数据结构]()

- 加载`.class`文件的方式
    - 从本地系统中直接加载

    - 通过网络下载 `.class` 文件
    
    - 从 `zip、jar` 等归档文件中加载 `.class` 文件
    
    - 从专有数据库中提取 `.class` 文件
    
    - **将Java源文件动态编译为 `.class` 文件**

- **类的加载的最终产品是位于内存中的 Class 对象**

- **Class 对象封装了类在方法区内的数据结构**，并且向 Java 程序员提供了访问方法区内的数据结构接口

### 类加载器

&emsp;&emsp;类加载器用来把类加载到 Java 虚拟机中，从 JDK1.2 版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证 Java 平台的安全，在此委托机制中，除了 Java 虚拟机自带的根类加载器以外，其余类加载器都有且只有一个父类加载器。当 Java 程序请求加载器 loader1 加载 Sample 类时，loader1 首先委托自己的父加载器去加载 Sample 类，若父加载器能加载，则由父加载器完成任务，否则才由加载器 loader1 本身加载 Sample 类

&emsp;&emsp;有两种类型的类加载器

- **Java 虚拟机自带的类加载器**
    - 根类加载器（Bootstrap）  

        **该加载器没有父加载器**，负责加载虚拟机的核心类库，如 java.lang.* 等，java.lang.Object 是由根类加载器加载的。根加载器从系统属性 sun.boot.class.path 所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承 java.lang.ClassLoader 类

    - 扩展类加载器（Extension）  
      
        **父类是根类加载器**
    
    - 系统（应用）类加载器（System)   
      
        **父类是扩展类加载器**

- **用户自定义的类加载器**
    - java.lang.ClassLoader 的子类

    - 用户可以定制类的加载方式

- 类加载器并不需要等到某个类被“**首次主动使用**”时再 **加载** 它
  
    - JVM 规范允许类加载器在预料某个类将要被使用时预先加载它，如果在预先加载的过程中遇到了`.class`文件缺失或存在错误，类加载器必须在 **程序首次主动使用该类时** 才报告错误 (LinkageError错误)
- 如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误

### ClassLoader

获取 ClassLoader 的途径

- 获取当前类的 ClassLoader ：  clazz.getClassLoader()

- 获取当前线程的上下文的 ClassLoader ：Thread.currentThread().getContextClassLoader()

- 获取系统的 ClassLoader ：ClassLoader.getSystemClassLoader()

- 获取调用者的 ClassLoader ：DriverManager.getCallerClassLoader()

### 双亲委托机制

- 在双亲委托机制当中，各个加载器按照父子关系形成了逻辑上的 **树形结构**，除了根类加载器之外，其余的类加载器都有且只有一个父加载器
- 用通俗的话说：当一个类加载器想加载一个类时，不是马上通过自己去加载类，而是把加载的动作委托给父亲去完成，父亲上面如果还有父亲，就继续委托给父亲的父亲去完成，直到最顶层的根类加载器，如果根类加载器没能加载成功，会将委托传回给扩展类加载器，如果扩展类加载器也不能加载则继续回传，直到有类加载器能加载类，则加载动作完成，退回到最初的类加载器

```java
自    |---------------------|     自    加载 JRE\lib\rt.jar 或者
顶 ↑  |Bootstrap ClassLoader|  ↓  顶    Xbootclasspath 选项指定的 jar 包 
向 ↑  |---------------------|  ↓  向    
上 ↑                           ↓  下
检 ↑  |---------------------|  ↓  尝    加载 JRE\lib\ext\*.jar 或者
查 ↑  |Extension ClassLoader|  ↓  试    Djava.ext.dirs 指定目录下的 jar 包
类 ↑  |---------------------|  ↓  加 
是 ↑                           ↓  载
否 ↑  |---------------------|  ↓  类    加载 CLASSPATH 或 Djava.class.path 
已 ↑  |   App ClassLoader   |  ↓  2.    所指定的目录下的类和 jar 包
经 ↑  |---------------------|  ↓ 
加 ↑                           ↓
载    |---------------------|           通过 java.lang.ClassLoader 的子类
1.    | Custom  ClassLoader |           自定义加载 class
      |---------------------|    
```

- 若有一个类加载器能够成功加载 Test 类，那么这个类加载器被称为 **定义类加载器**，所有能成功返回 Class 对象引用的类加载器（包括定义类加载器）都被称为 **初始类加载器**



## 类的连接

### 类的验证
- 类被加载后，就进入到 **连接** 阶段。连接就是将已经读入到内存的类的二进制数据 **合并到** 虚拟机的运行环境中去

- 类的验证内容
    - 类文件的结构检查
    
    - 语义检查

    - 字节码检查

    - 二进制兼容性的验证

### 类的准备
```java
public class Smaple{
    private static int a = 1;

    private static long b;

    static {
        b = 2;
    }
}
```
在准备阶段，Java 虚拟机为类的静态变量分配内存，并设置默认初始值，例如，在上述代码中，在 Sample 类的准备阶段，虚拟机为 int 类型的静态变量 a 分配 4 个字节的内存空间，并且赋默认值为 0。为 long 类型的静态变量 b 分配 8 个字节的内存空间，并且赋默认值为 0。

## 类的初始化

- 初始化步骤
    - 假如这个类还有被 **加载** 和 **连接**，那么就先进行加载和连接

    - 假如类存在直接父类，并且这个类还有被初始化，那么先 **初始化** 其父类

    - 假如类中存在初始化语句，那么依次执行这些初始化语句

- Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口
    - 在初始化一个类时，并不会先初始化它所实现的接口
    
    - 在初始化一个接口时，并不会先初始化它的父接口

    因此，一个父接口并不会因为它的子接口或实现类被初始化而初始化，只有当程序在首次使用该接口的静态变量时，才会导致该接口的初始化

- 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用

- 调用 ClassLoader 类的 loadClass 方法加载一个类时，并不是对类的主动使用，不会导致类的初始化

- 
    ```java
    public class Smaple{
        private static int a = 1; // 在声明处初始化

        private static long b;

        private static long c;

        static {
            b = 2;                // 在静态代码块中初始化
        }
    }
    ```
    在类的初始化阶段，Java 虚拟机执行类的初始化语句，为类的静态变量 **赋予初始值**。在程序中，静态变量的初始化有两种途径：1. 在静态变量声明处进行初始化；2. 在静态代码块中初始化。如上述代码，静态变量 a 和 b 都进行了显式的初始化，而静态变量 c 没有显示初始化，它还是默认值 0

- 
    ```java
    public class Smaple{
        private static int a = 1; 

        static {
            a = 2;                
        }
    static {
            a = 4;                
        }
    
    public static void main(String[] args){
            System.out.print(a); // a = 4
        }
    }
    ```
    静态变量的声明语句和静态代码块都被看作类的初始化语句，Java 虚拟机会按照初始化语句在类文件中先后顺序来依次执行它们，例如，当上述类 Sample 被初始化后，它的静态变量 a 的值为 4

