## 类加载

- 在 Java 代码中，类型的 **加载**、**连接** 与 **初始化** 过程都在 **程序运行期间** 完成

- 提供了更大的灵活性，增加了更多的可能性

### Java 虚拟机与程序的生命周期

在如下的几种情况，Java 虚拟机将结束生命周期
- 执行了 `System.exit()` 方法

- 程序正常执行结束

- 程序在执行过程中遇到了异常或错误而异常终止虚拟机

- 由于操作系统出现错误导致虚拟机进程终止

### 类的加载、连接、初始化

从磁盘到内存的过程

- 加载：查找并加载类的二进制数据

- 连接：
    - 验证：确保被加载类的正确性

    - 准备：为类的 **静态变量** 分配内存，并将其初始化为 **默认值**
        ```java
        public class Test{
            private static int a = 1;
        }
        ```
       int 类型的默认值 0
    - 解析：把类中的 **符号引用** 转化为 **直接引用**

- **初始化：为类的静态变量赋予正确的初始值**
    ```java
    // 将上面的 a 赋值 1
    ```
<!-- TODO 画个图 -->
```java
|—— —— ——|    |—— —— —— —— ——|
|        | -> |  |—— —— ——|  |
|—— —— ——|    |  |        |  |        
              |  |—— —— ——|  |
              |      |       |
              |      ↓       |
              |  |—— —— ——|  |
              |  |        |  | 
              |  |—— —— ——|  | 
              |      |       |
              |      ↓       |
              |  |—— —— ——|  |
              |  |        |  |    |—— —— ——|              
              |  |—— —— ——|  | -> |        |
              |—— —— —— —— ——|    |—— —— ——|                
```

- Java 对类的使用方式分为两种
    
    - [主动使用](#主动使用)有七种

    - [被动使用](#被动使用)

- 所有的 Java 虚拟机实现必须在每个类或接口被 Java 程序 **首次主动使用** 时才初始化它们

### 主动使用

- **创建类的实例**

- **访问某个类或者接口的静态变量，或者对该静态变量赋值**
    ```java
    /**
     * ✨对于静态字段来说，只有直接定义了该字段的类才会被初始化
     * ✨当一个类在初始化时，要求其父类全部已经初始化完毕
     */
    class Parent {
        public static String str = "hello Parent";
        static {
            System.out.println("Parent static");
        }
    }

    class Child extends Parent {
        public static String str2 = "hello Child";
        static {
            System.out.println("Child static");
        }
    }

    public class StaticClassTest {
        public static void main(String[] args) {
            System.out.println(Child.str);
        }
    }
    // 结果
    // Parent static
    // hello Parent
    
    // 可能会疑问，为什么没有输出 Child 中的 static 代码块呢
    // 因为，通过 Child 访问 Parent 中的 str，只访问了 Parent，所以初始化了 Parent 类，加载类中的静态代码块
    ```

    ```java
    // 将上述代码中的主方法中改为下面
    public class StaticClassTest {
        public static void main(String[] args) {
            System.out.println(Child.str2);
        }
    }

    // 结果
    // Parent static
    // Child static
    // hello Child

    // 此时是访问了 Child 类中的静态变量，加载 Child 时先加载其父类，运行父类的静态代码块，加载完毕后再加载 Child 类中的静态代码块，最后输出
    ```


- **调用类的静态方法**

- **反射 如 Class.forName("com.liy.Test");**

- **初始化一个类的子类时**

- **Java 虚拟机启动时被标明为启动类的类（Java Test) 如包含了 main 方法**

- JDK1.7 提供的动态语言支持，java.lang.invoke.MethodHandle 实例的解析结果 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic` **句柄对应的类没有初始化时则初始化**

### 被动使用
除了上述 **7** 种情况外，其他都是被动使用，都不会导致类的 **初始化**(三个步骤中的第三个)

### 类的使用和卸载
- 使用

- 卸载：从内存中销毁掉

### 类的加载

- 类的加载指的是将类的`.class`文件中的二进制数据读入到内存中，将其放在**运行时数据区**的**方法区**内，然后在内存中创建一个 java.lang.Class 对象（规范并未说明 Class 对象位于哪里，HotSpot 虚拟机将其放在了方法区中）[✨用来封装类在方法区内的数据结构]()

- 加载`.class`文件的方式
    - 从本地系统中直接加载

    - 通过网络下载 `.class` 文件
    
    - 从 `zip、jar` 等归档文件中加载 `.class` 文件
    
    - 从专有数据库中提取 `.class` 文件
    
    - **将Java源文件动态编译为 `.class` 文件**

