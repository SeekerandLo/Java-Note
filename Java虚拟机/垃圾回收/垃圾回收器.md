## 垃圾回收器

&emsp;&emsp;垃圾回收器是实现垃圾回收算法并应用在 JVM 环境中的内存管理模块。

### Serial
&emsp;&emsp;Serial 回收器是一个主要应用于 YGC 的垃圾回收器，采用串行单线程的方式完成垃圾回收

#### STW(Stop the World)
&emsp;&emsp;垃圾回收的某个阶段会暂停整合应用程序的执行。

### CMS

&emsp;&emsp;**Concurrent Mark Sweep Collector**，是回收停顿时间较短，现在常用的垃圾回收器。**常用于老年代**，通过初始标记、并发标记、重新标记、并发清除四个步骤完成垃圾回收工作

- 初始标记：会触发 STW，这个阶段会标记所有与 GC Roots **直接关联的对象(老年代中)**及被存活的年轻代所**直接引用**的对象---------待看

- 并发标记，并发的标记执行任务，此阶段，应用程序也不会停止工作，垃圾回收器从第一个阶段标记的对象出发，遍历所有与之直接或间接关联的对象，标记上。

    - 并发问题，可能会遗漏一些老年代的对象，因为在并发过程中，应用程序可能改变对象的引用情况

- 并发预清理，主要目的是减少重标记（Remark）步骤 Stop-the-World 的时间。这一步同样也是并发的，不会停止用户应用线程。在前面的并发标记中，一些引用被改变了。当某一块块（Card）中的对象引用发生改变时，JVM会标记这个空间为“脏块”（Dirty Card）。在预清理阶段，JVM根据之前记录的这些“脏对象”重新标记了他们新的可达对象。这一步结束后空间重新进入clean状态。另外，一些必要的最终重标记之前的准备步骤也会在这一步做好。

- 重新标记，此阶段会触发 Stop-the-World，由于前一个步骤是并发的步骤，预清理的速度可能赶不上对象关系的变化，所以需要一个阶段来暂定程序运行，完成所有的标记。通常 CMS 会在年轻代为空时来运行重标记阶段，以此避免一个接一个的 STW。

- 并发清除，移除所有不用的对象，并且重新生命内存空间的归属等候将来使用。

#### CMS 会导致大量的空间碎片，如何解决

- `-XX:+UseCMSCompactAtFullCollection`，强制 JVM 在 FGC 完成后对老年代进行压缩，执行一次空间碎片整理，但是空间碎片整理阶段会触发 STW。为了减少 STW 的次数，CMS 还可以配置 `-XX:CMSFullGCsBeforeCompaction=n`，在执行 n 次 FGC 之后，再整理空间碎片。

### G1

&emsp;&emsp;G1 具备压缩功能，能避免碎片问题，G1 的暂停时间更加可控。G1 将 Java 堆空间分割成了若干相同大小的区域，即 region，包括 Eden，Survivor，Old，Humongous，其中 Humongous 是特殊的 Old 区，专门放置大型对象。  
&emsp;&emsp;G1 将空间分为多个区域，优先回收垃圾最多的区域，采用 Mark-Copy 算法，有非常好的空间整合能力，不会产生大量的空间碎片。  
&emsp;&emsp;G1 的一大优势在于可以预测的停顿时间，能够尽可能快地在指定时间内完成垃圾回收任务。
