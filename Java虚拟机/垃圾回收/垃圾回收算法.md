## 垃圾回收算法

### 如何判断一个对象可以被垃圾回收

&emsp;&emsp;JVM 引入了 GC Roots，如果一个对象与 GC Roots 没有任何直接或间接引用关系，那么这个对象可以被回收

### GC Roots

- 类静态属性中引用的对象

- 常量引用的对象

- 虚拟机栈中引用的对象

- 本地方法栈中引用的对象

#### 为什么使用这些对象作为 GC Roots？

### 标记清除算法

&emsp;&emsp;该算法会从每个 GC Roots 出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。  
&emsp;&emsp;这个算法会产生大量的空间碎片，导致需要分配一个较大连续空间时容易出发 FGC。

#### 什么时候会触发 FGC

&emsp;&emsp;当老年代无法存放新对象时，会触发 FGC，Full Garage Collection。

### 标记整理算法

&emsp;&emsp;为了解决标记清除算法导致的问题，设计出了标记整理算法，首先从 GC Roots 出发，标记所有存活的对象，然后将存活的对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片问题。

### Mark-Copy算法

&emsp;&emsp;为了能够并行的标记和整理，将空间分为两块，每次只激活一块，垃圾回收时只需把存活的对象复制到另一块未激活空间上，将未激活空间标记为已激活，将已激活标记为未激活，然后清除原空间中的原对象。  
&emsp;&emsp;堆内存空间分为较大的 Eden 和两块较小的 Survivor 区，每次只使用 Eden 区和一块 Survivor 区。
&emsp;&emsp;Mark-Copy 作为主流的 YGC 算法进行新生代的垃圾回收。