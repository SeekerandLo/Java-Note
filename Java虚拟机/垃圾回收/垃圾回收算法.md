### 如何判断一个对象可以被垃圾回收

&emsp;&emsp;可达性分析算法，以 GC Roots 为起始点，从起始点出发，向下搜索，走过的路径叫引用链，如果一个对象到任何一个 GC Roots 都没有引用链，那么称这个对象不可达

### GC Roots

- 类静态属性中引用的对象

- 常量引用的对象

- 虚拟机栈中引用的对象

- 本地方法栈中引用的对象

### 为什么使用这些对象作为 GC Roots？

***

## 垃圾回收算法

### 1.标记清除算法

&emsp;&emsp;该算法会从每个 GC Roots 出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。  
&emsp;&emsp;这个算法会产生大量的空间碎片，导致需要分配一个较大连续空间时容易出发 FGC。

### 2.标记整理算法

&emsp;&emsp;为了解决标记清除算法导致的问题，设计出了标记整理算法，首先从 GC Roots 出发，标记所有存活的对象，然后将存活的对象整理到内存空间的一端，形成连续的已使用空间，最后把已使用空间之外的部分全部清理掉，这样就不会产生空间碎片问题。

### 3.复制算法

&emsp;&emsp;为了能够并行的标记和整理，将空间分为两块，每次只激活一块，垃圾回收时只需把存活的对象复制到另一块未激活空间上，将未激活空间标记为已激活，将已激活标记为未激活，然后清除原空间中的原对象。  
&emsp;&emsp;堆内存空间分为较大的 Eden 和两块较小的 Survivor 区，每次只使用 Eden 区和一块 Survivor 区。
&emsp;&emsp;Mark-Copy 作为主流的 YGC 算法进行新生代的垃圾回收。

### 4.分代回收算法

&emsp;&emsp;根据对象的生存周期将内存分成两块，新生代和老年代，然后根据两个区域中的对象生成死亡情况选择更合适的垃圾回收算法。  
&emsp;&emsp;新生代中的对象每次垃圾回收时都有大量的对象死亡，只有少量的存活，所以选择复制算法，只需要付出少量存活对象复制的成本就能完成垃圾回收。而老年代中存活的对象较多，没有额外的空间给它分配担保，使用标记清除或者标记整理算法回收。

***

### 为什么会有老年代和新生代


### 新生代分区

- Eden ：SurvivorTo ： SurvivorFrom = 8 ：1 ：1

### 新生代为什么如此分区

&emsp;&emsp;新生代中的对象一般生命不长，可能很快就死亡（<-），所以不需要按照 `1 ：1` 来分配内存空间，于是将内存分为三个区域，一个 Eden 区和两个 Survivor 区，每次使用 Eden 区和一个 Survivor 区。  
&emsp;&emsp;当回收时将 Eden 区和 Survivor 区中存活的对象复制到另一个 Survivor 区中，然后清除掉使用的区域。

### MinorGC 和 FullGC

- MinorGC/YoungGC：新生代 GC，新生代对象死的快，回收频繁。

- MajorGC/FullGC：老年代 GC，MajorGC 速度一般比 MinorGC 慢 10 倍以上。