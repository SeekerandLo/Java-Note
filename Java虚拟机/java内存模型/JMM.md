## JMM Java Memory Model Java 内存模型

### 分类

- 主内存：JMM 规定所有的变量都存储在主内存中，类比 Java 运行时数据区域的堆内存

- 工作内存：每个线程又有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本拷贝，线程对变量的操作都应该在工作内存中进行，而不能直接修改主内存中的变量。不同线程间也无法访问对方工作内存中的变量，线程间变量值的传递需要依赖主内存完成。类比 Java 运行时数据区域中的虚拟机栈

### 内存间的相互操作 [一个变量如何从主内存中拷贝到线程的工作内存中，再从工作内存同步到主内存中] [8种操作]

- lock(锁定)：作用于**主内存**中的变量，把一个变量标识为一个线程独占的状态

- unlock(解锁)：作用于**主内存**中的变量，把一个锁定状态的变量释放出来，释放出来的变量可以被其他线程锁定

- read(读取)：作用于**主内存**中的变量，把主内存中的变量传输到线程的工作内存中去，以便之后的 load 动作使用

- load(载入)：作用于**工作内存**中的变量，把 read 操作从主内存中得到的变量放入工作内存的变量副本中去

- use(使用)：作用于**工作内存**中的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机执行到使用变量的指令的时候就会调用此操作

- assign(赋值)：作用于**工作内存**中的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会调用此操作

- store(存储)：作用于**工作内存**中的变量，把工作内存中的一个变量的值传送到主内存当中，以便随后的 write 操作使用

- write(写入)：作用于**主内存**中的变量，把 store 操作从工作内存中得到的变量放入主内存中的变量中

### 操作的一些规定

- 不允许 read 和 locd 或 store 和 write 单独出现，即不能出现一个变量从主内存传输到工作内存中，而工作内存不接收，或者从工作内存回写到主内存中而主内存不接收的情况

- 不允许一个线程丢弃 assign 操作，即一个变量改变了，必须要同步回主内存

- 不允许一个线程无原因的把一个变量从工作内存同步回主内存

- 一个新的变量只能在主内存中产生，不允许直接在工作内存中使用一个未初始化的变量，换句话说，在对一个变量实施use、store操作之前，必须先执行过了 assign 和 load 操作

- 一个变量在同一时刻只允许一个线程对其 lock，但是 lock 操作可以被同一线程执行多次，多次执行 lock 后，只要再执行同样次数的 unlock 变量才会被解锁

- 如果对一个变量使用了 lock，就会清除工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值

- 如果一个变量事先没有被 lock 锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量

- 对一个变量执行 unlock 之前，必须先把此变量同步回主内存中(执行 store、write)