## 数据并发的问题

- **以下内容大都来自《精通Spring4.x 企业应用开发实战》**

- 一个数据库可能拥有多个访问客户端，这些客户端都可用并发的方式访问数据库。数据库中的相同数据可能同时被多个事务访问,**如果没有采取必要的隔离措施**,就会**导致各种并发问题**，破坏数据的完整性.这些问题可以归结为 5 类

- 数据读问题(3)

    - [脏读](#脏读)

    - [不可重复读](#不可重复读)

    - [幻象读](#幻象读)

- 数据更新问题(2)

    - 当两个事务更新同一行时，但彼此不知道对方，一个事务更新完，另一个事务在其提交之前也更新数据，最后提交，这样就导致了更新丢失

    - [第一类丢失更新](#第一类丢失更新)

    - [第二类丢失更新](#第二类丢失更新)

>**更新丢失**（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改保存其更改副本的编辑人员覆盖另一个编辑人员所做的修改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。  

> **脏读**（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。  

>**不可重复读**（Non-Repeatable Reads）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。  

>**幻读**（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”

### 脏读

- A事务读取了B事务尚未提交的更改数据，并在这个基础上进行操作

- 例：A事务想读取数据，B事务正在修改，还没提交，A事务读取到了B事务修改后的数据。

### 不可重复读

- A事务读取了B事务已经提交的**更改数据**

- 例：A事务先读取一次数据，在这之后，B事务更新数据，A事务又读取了一次数据，两次数据不一样

### 幻象读

- A事务读取到了B事务提交的**新增数据**

- 例：A事务先读取一次数据，在这之后，B事务又提交一条数据，A事务又读取一次数据，两次数据不一样

### 区分幻象读和不可重复读

- 幻想读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，后者是读到了已经提交事务的更改数据（更改或删除）

- **防止不可重复读可以使用行锁**

- **防止幻象读可以使用表锁**



### 第一类丢失更新

- A事务撤销时，把已经提交的B事务的更新数据覆盖了

### 第二类丢失更新

- A事务覆盖B事务已经提交的数据，造成B事务所作的操作丢失