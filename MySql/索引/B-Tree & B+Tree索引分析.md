## B-Tree & B+Tree 索引分析

### 磁盘读取原理

&emsp;&emsp;索引占用的空间很大，所以需要存放在物理存储上。而通过查找索引获取数据时间主要浪费在将物理存储(磁盘)中的数据读到内存，所以应尽量减少从磁盘读取数据到内存中的次数。为了达到这个目的，操作系统在读取数据的时候采用**磁盘预读**的方式，每次读取一块数据到内存中，这遵循局部性原理

>当一个数据被用到时，其附近的数据也通常马上被使用

&emsp;&emsp;磁盘预读的效率很高，因为顺序读取耗费的时间很少。预读的单位是**页**，页是存储的逻辑单位，把磁盘分割成大小相等的连续的块，每个存储块被称为页，一个页的大小是 4k，主存和磁盘交换数据都是以页为单位，当程序读取的数据不再内存中时，会触发缺页异常，此时系统会读取磁盘，磁盘找到数据的起始位置并向后读取一页或几页到内存中。

### B-Tree 索引

&emsp;&emsp;B-Tree 索引将每个节点的大小设为一页，这样每次都会读取一个节点只需要一次磁盘I/O，B-Tree 中一次检索最多执行 h-1 次磁盘I/O(B-Tree 根节点在内存中，树的高度为 h)

### B+Tree 索引

&emsp;&emsp;B+Tree 与 B-Tree 的区别就是，B+Tree 的非叶子节点只存放索引和 key，在叶子节点只存放数据

### 🙃为什么数据库索引使用 B+Tree 而不使用 B-Tree 或者红黑树

- https://blog.csdn.net/xiedelong/article/details/81417049

### 为什么MySQL的索引要使用B+树，而不是使用B树

&emsp;&emsp;因为 B 树不管是叶子节点还是非叶子节点都会保存数据，这样会导致非叶子节点能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。

### 为什么索引使用 B+Tree 而不使用红黑树

&emsp;&emsp;红黑树还是二叉树，B+Tree 是多路平衡查找树，
因为索引占据内存很大，所以需要存放在磁盘上，而磁盘到内存操作就是耗费时间的主要操作。

### hash 索引和 B+Tree 索引什么时候使用

&emsp;&emsp;hash 索引底层使用的是 hash 表，存储 k-v 结构，数据在存放是无序的，所以他不适应区间查询，更适合等值查询。

&emsp;&emsp;B+Tree 索引将数据都存放在叶子节点上，且索引都是按顺序排列的，所以更适合区间查询。
