### 1.Redis 支持哪几种类型的数据类型

- string 字符串类型 最基本的数据类型 最大存储数据量512M，其余几种类型的最大存储数据量为2^32-1
- list 列表类型 单key多value
- hash 哈希类型 value是一个键值对类型，类似于java中的Map<String,Object>
- set 集合 单key多value 集合中不允许有重复的value
- zset 有权值的集合 有序 单key多value 在添加value时带有权值

### 2.Redis 的主要功能
- 主从复制，主机数据更新后根据配置和策略自动更新同步到备机的master/slaver机制，master以写为主，slaver以读为主。
    - 读写分离
    - 容灾恢复
    - 如何配置
    - 复制原理
    - 哨兵模式
    - 缺点
- 事务
- Lua脚本
- 持久化
    - AOF
    - RDB
- 集群

### 3.介绍 Redis 的复制
- 慨念：主从复制，主机数据更新后根据配置和策略自动更新同步到备用机的master/slaver机制，如果主机挂掉，自动跳到备用机。
- 怎么操作（一主机多从机）
    - 配置从库，在从库输入命令
    ```
    slaveof host port // 配置从机 
    
    info replication //  查看redis服务器的关系信息
    ```
    - 如何取消：linux上重新用redis-server加载新的配置文件，可以取消，windows上目前不知道，我是卸载重新安装的😥
    - 配置从库连接到主库后，从库会直接复制主库的数据，如果运行过程中主库死掉了，从库会原地待命等待主库归来，主库重新启动后一切照旧，如果从机死掉了，需要重新配置`slaveof`，与主库建立起连接，除非写入到`redis.conf`文档中。 [👉redis配置]() 
- 怎么操作（薪火相传）
    - 上一个slaver可以是下一个slaver的master，slaver同样可以接受其他slaver的连接请求，该slaver作为链条中的下一个master，可以有效减轻master的`写`的压力 
    - 中途变更转向，会清除之前的数据，重新建立拷贝最新的
    - slaveof 新主机IP 新主机端口
    - 依次设置主机从机
- 怎么操作（反客为主）
    - 如果主机挂掉，从机变主机
    ```
    slaveof no one //手动的把从机改为主机
    ```
    - 使当前数据库停止与其他数据库的同步，转为主数据库
- 复制的原理
    - slaver连接到master后发送sync命令
    - master接受到命令启动h后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，master将传送整个数据集到slaver完成一次数据同步
    - `全量复制`，第一次连接进行全量复制
    - `增量复制`，以后从库对主库都是增量复制
    - 如果出现关机重连情况，会自动触发一次`全量复制`
- 哨兵模式（sentinel）
    - 自动监控的机制，`反客为主`的自动版，后台监控主机是否故障，如果故障了根据投票数自动将从库变为主库
    - 新建`sentinel.conf`文件，输入如以下例子
    ```
    sentinel monitor 数据库名字(自定义) ip地址 port 1 // 最后的1代表投票机制，票高的为以后的主库
    ```
    - redis-sentinel /路径/sentinel.conf 启动哨兵模式，开启自动监管，当主库死掉后，会自动的把一个从库升级为主库，如果主库再回来变为从库
    - 一个哨兵可以监控多个master
- 复制的缺点
    - 由于所有的写操作都在master上，然后同步更新到slaver上，有一定的延迟，当网络繁忙的时候和多slaver的时候，这种情况会更加严重
    - 如何取消哨兵机制

### 4.介绍 Redis 的事务
- 事务是一个单独隔离的操作，是一组命令的集合，事务中的命令会按顺序执行，并且不会被其他命令中断，还是一个原子操作，要么全部执行，要么全部不执行，一个队列中，一次性的，顺序性的执行命令
- 特殊情况
    - 1.当在事务开启时，输入的命令有错误的命令，如：命令错误，最后导致事务不执行
    - 2.事务开启，输入的命令没有问题，但是输入的不合常理，如:
    ```
    set a
    lpop a
    ```
    这样的命令不该同时出现，此时执行`exec`命令会执行，但是只有正确的执行，错误的执行后报错
- watch监控
    - 乐观锁/悲观锁/CAS(Check and Set)[👉锁]()
        - 悲观锁：很悲观的锁，每次在修改数据时都认为别人会修改数据导致问题，所以每次在修改数据时都把数据锁上，等改完数据后再放开，有很多这种锁机制，如：行锁，表锁，读锁，写锁等，都是在写之前先上锁
        - 乐观锁：很乐观的锁，每次去读取数据时都认为别人不会修改数据，但是更新时会判断数据是不是最新的，可以通过版本号等机制[👉乐观锁实现]()，乐观锁适用于多读的应用类型，这样可以提高吞吐量
        - CAS
    - 用watch监控某个key，启动一个事务，当在事务未执行前，如果有其他的命令修改了key下的value，则事务最后会执行失败
    - unwatch，取消对所有key的监控，当执行`exec`命令后也会取消对所有key的监控

### 5.介绍 Redis 的持久化

### 6.介绍 Redis 的集群

### 7.Redis 是单进程单线程的吗？

### 