1. [数据类型](#1redis-支持哪几种类型的数据类型)  
2. [Redis的主要功能](#2redis-的主要功能)
3. [Redis的持久化](#5介绍-redis-的持久化)
4. [Redis的事务](#4介绍-redis-的事务)
5. [Redis的复制](#3介绍-redis-的复制)


### 1.Redis 支持哪几种类型的数据类型

- string 字符串类型 最基本的数据类型 最大存储数据量512M，其余几种类型的最大存储数据量为2^32-1
- list 列表类型 单key多value
- hash 哈希类型 value是一个键值对类型，类似于java中的Map<String,Object>
- set 集合 单key多value 集合中不允许有重复的value
- zset 有权值的集合 有序 单key多value 在添加value时带有权值

### 2.Redis 的主要功能
- 主从复制，主机数据更新后根据配置和策略自动更新同步到备机的master/slaver机制，master以写为主，slaver以读为主。
- 事务
- Lua脚本
- 持久化
- 集群

### 3.介绍 Redis 的持久化
- RDB(Redis DataBase)
    - 在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存里
    - Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，在持久过程都结束后，再将这个临时文件替换上次持久化好的文件
    - 在整个过程中，主进程不进行IO操作，确保了极高的性能
    - 如果需要进行大规模的数据恢复，且对数据完整性不是非常**敏感**的话，RDB模式比AOF模式更高效，因为RDB有一个缺点是最后一次持久化后的数据可能丢失
    - **Fork**：fork的作用是复制一个和当前进程完全一样的进程，新进程的所有数据都和原进程一样，但是是一个全新的进程，作为原进程的子进程
    - 保存文件为dump.rdb
    - 配置
        - 有三种默认的策略，可根据实际情况修改，15min之内有1个key的值改变，5min之内有10个key的值改变，60s之内有10000个key的值改变，会自动触发
        ```
        save 900 1
        save 300 10
        save 60 10000
        ```
        - 禁用
        ```
        save ""
        ```
        - 直接备份
        ``` 
        save //save 只管保存，其他不管，阻塞
        bgsave //redis 会在后台异步执行快照操作，还可以响应客户端的命令，还能通过lastsave获取最后一次成功执行的时间
        ```
        - Stop-write-on-bgsave-error(如果save失败了要停止写),默认 yes，如果改成no代表不在乎数据不一致，或者有其他的手段可以控制
        - rdbcompression：压缩，对于存储到磁盘中的快照，可以设置是否进行压缩存储，如果是的话，redis会采用LZF压缩算法，如果不想消耗cpu来进行压缩，可以关闭
        - rdbchecksum：存储快照后，可以让redis使用CRC64算法来进行数据检验，但是会加大内存的消耗，可以设置为关闭
        - dbfilename：rdb文件的名字
        - dir：存放的路径
    - 如何恢复：将备份文件移动到redis安装目录并启动服务即可
    - 优势：适合大规模的数据恢复，对数据完整性要求不高
    - 劣势：在一定时间间隔才备份一次，如果在redis意外死掉会丢失最后一次的修改。fork的时候，内存中的数据被克隆一份，大致2倍的膨胀性，需要考虑
    - 如何停止
    ```
    redis-cli config set save ""
    ```
- AOF(Append Only File)
    - 以日志的形式来记录每个`写操作`，将redis的所有写命令记录下来，读命令不记录，只许追加，不许改写文件，redis启动之初会重新读取日志，重新构建数据，也就是说，AOF的恢复就是重启redis服务，然后将日志中的指令重新执行一遍
    - 文件保存的是`aof`文件
    - 配置
        - 在redis.conf文件中将appendonly改为yes，如果之后的测试没有在安装目录出现aof文件，还要执行如下两条命令
        ```
        redis-cli config set appendonly yes // 开启AOF
        redis-cli config set save ""        // 关闭RDB  // 重启redis服务后执行这两条命令
        ```
    - **aof和rdb文件可以同时存在，如果同时存在，先加载aof文件，如果失败运行如下命令**
    ```
    redis-check-aof --fix appendonly.aof // 修复aof文件
    ```
    - AOF配置策略
        - appendfsync：三个选择 `everysec`，`always`，`no`
            - always：同步持久化，每次发生数据的变更都会立即记录到磁盘，性能较差但是数据保存完好
            - `everysec`：默认设置，异步操作，每秒记录，如果一秒内宕机，会丢失一些记录
            - no：不同步
        - no-appendfsync-on-rewrite：重写时是否可以运用appendfsync，用默认no即可，保证数据安全性
        - auto-aof-rewrite-min-size：设置重写的基准值
        - auto-aof-rewrite-percentage：设置重写的百分比 
    - 重写机制
        - 当aof文件超过预期的阈值后，redis会启动aof文件的内容压缩，只保留能够恢复数据的最少指令集，可以使用命令`bgrewriteaof`
        - 原理：aof文件持续增长而过大时，会`fork`出一个新进程来“重写”aof文件，先写临时文件最后再rename，没有读取以前的aof文件，而是遍历数据库中的数据，每条记录有一个set语句。以此来重写文件，这个和快照有点类似
        - 触发机制：redis会记录上次重写时的aof文件大小，默认配置是当aof文件大小是上次rewrite后大小一倍且文件大小大于`64M`时触发
- RDB与AOF
    - 二者可以共存
    - 各有优劣
    - 性能建议：同时开启


### 4.介绍 Redis 的复制
- 概念：主从复制，主机数据更新后根据配置和策略自动更新同步到备用机的master/slaver机制，如果主机挂掉，自动跳到备用机。
- 怎么操作（一主机多从机）
    - 配置从库，在从库输入命令
    ```
    slaveof host port // 配置从机 
    
    info replication //  查看redis服务器的关系信息
    ```
    - 如何取消：linux上重新用redis-server加载新的配置文件，可以取消，windows上目前不知道，我是卸载重新安装的😥
    - 配置从库连接到主库后，从库会直接复制主库的数据，如果运行过程中主库死掉了，从库会原地待命等待主库归来，主库重新启动后一切照旧，如果从机死掉了，需要重新配置`slaveof`，与主库建立起连接，除非写入到`redis.conf`文档中。 [👉redis配置]() 
- 怎么操作（薪火相传）
    - 上一个slaver可以是下一个slaver的master，slaver同样可以接受其他slaver的连接请求，该slaver作为链条中的下一个master，可以有效减轻master的`写`的压力 
    - 中途变更转向，会清除之前的数据，重新建立拷贝最新的
    - slaveof 新主机IP 新主机端口
    - 依次设置主机从机
- 怎么操作（反客为主）
    - 如果主机挂掉，从机变主机
    ```
    slaveof no one //手动的把从机改为主机
    ```
    - 使当前数据库停止与其他数据库的同步，转为主数据库
- 复制的原理
    - slaver连接到master后发送sync命令
    - master接受到命令启动h后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，master将传送整个数据集到slaver完成一次数据同步
    - `全量复制`，第一次连接进行全量复制
    - `增量复制`，以后从库对主库都是增量复制
    - 如果出现关机重连情况，会自动触发一次`全量复制`
- 哨兵模式（sentinel）
    - 自动监控的机制，`反客为主`的自动版，后台监控主机是否故障，如果故障了根据投票数自动将从库变为主库
    - 新建`sentinel.conf`文件，输入如以下例子
    ```
    sentinel monitor 数据库名字(自定义) ip地址 port 1 // 最后的1代表投票机制，票高的为以后的主库
    ```
    - redis-sentinel /路径/sentinel.conf 启动哨兵模式，开启自动监管，当主库死掉后，会自动的把一个从库升级为主库，如果主库再回来变为从库
    - 一个哨兵可以监控多个master
- 复制的缺点
    - 由于所有的写操作都在master上，然后同步更新到slaver上，有一定的延迟，当网络繁忙的时候和多slaver的时候，这种情况会更加严重
    - 如何取消哨兵机制

### 5.介绍 Redis 的事务
- 事务是一个单独隔离的操作，是一组命令的集合，事务中的命令会按顺序执行，并且不会被其他命令中断，还是一个原子操作，要么全部执行，要么全部不执行，一个队列中，一次性的，顺序性的执行命令
- 特殊情况
    - 1.当在事务开启时，输入的命令有错误的命令，如：命令错误，最后导致事务不执行
    - 2.事务开启，输入的命令没有问题，但是输入的不合常理，如:
    ```
    set a
    lpop a
    ```
    这样的命令不该同时出现，此时执行`exec`命令会执行，但是只有正确的执行，错误的执行后报错
- watch监控
    - 乐观锁/悲观锁/CAS(Check and Set)[👉锁]()
        - 悲观锁：很悲观的锁，每次在修改数据时都认为别人会修改数据导致问题，所以每次在修改数据时都把数据锁上，等改完数据后再放开，有很多这种锁机制，如：行锁，表锁，读锁，写锁等，都是在写之前先上锁
        - 乐观锁：很乐观的锁，每次去读取数据时都认为别人不会修改数据，但是更新时会判断数据是不是最新的，可以通过版本号等机制[👉乐观锁实现]()，乐观锁适用于多读的应用类型，这样可以提高吞吐量
        - CAS
    - 用watch监控某个key，启动一个事务，当在事务未执行前，如果有其他的命令修改了key下的value，则事务最后会执行失败
    - unwatch，取消对所有key的监控，当执行`exec`命令后也会取消对所有key的监控


### 6.介绍 Redis 的集群

### 7.Redis 是单进程单线程的吗？

### 
