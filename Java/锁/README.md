## lock

### lock 与 synchronized 区别
[查看](https://www.cnblogs.com/baizhanshi/p/6419268.html)

## 悲观锁与乐观锁

- 悲观锁和乐观锁是锁根据性质分的类，并不特指某个锁，代表两种策略

- 悲观锁，就是很悲观，每次取数据时都认为别人修改了数据，所以每次拿数据都会上锁。这样别人无法拿数据，直到悲观锁释放

- 乐观锁。就是很乐观，每次取数据时都认为别人不会修改，所以不上锁，但是如果想要更新数据，则会在更新前至更新这段时间别人有没有修改数据。如果修改过，则重新读取，再次尝试更新，如果没有修改过，则直接更新。循环上述步骤直到更新成功。（也可以让更新失败的线程放弃操作）

- [👉通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！](https://zhuanlan.zhihu.com/p/71156910)

### 乐观锁实现方式及何时使用

- **何时使用**

    - 乐观锁适用于写操作比较少的情况，即确实很少冲突，这样可以省去解锁的开销，加大系统的吞吐量。核心操作就是 **回滚重试**，如果写操作较多，那么
    
    使用乐观锁就会不断的重试，降低程序的性能，这种情况下应该使用悲观所

- **实现方式**

    - **CAS**：Compare-And-Swap(Set)
    ```java
    // 示例demo
    int data = 123; 
    boolean flag = true;
    while (flag) {
        int oldValue = data; // 保存原始数据
        int newValue = doSomething(oldValue); 

        if (data == oldValue) { // 比较
            data = newValue; // 设置
            flag = false; // 结束
        } else {
        // 啥也不干，循环重试
        }
    }
    ```
    >  这是一个简单直观的乐观锁实现，它允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。 **CAS利用CPU指令，从硬件层面保证了操作的原子性**，以达到类似于锁的效果。因为整个过程中并没有“加锁”和“解锁”操作，**因此乐观锁策略也被称为无锁编程**。换句话说，乐观锁其实不是“锁”，它仅仅是一个**循环重试CAS的算法**而已！

### 悲观锁实现方式及何时使用

- 悲观锁适用于写操作较多的情况下，保护数据。

## synchronized 

- 静态方法锁的是**类的 class 的对象**，普通方法锁的 **this 对象**

- synchronized 是可重入锁