## 线程池的种类
`线程池`  
Java 通过 Executors 提供四种线程池，分别为：

- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

## 请说明一下线程池有什么优势

## 请回答一下Java中有几种线程池？并且详细描述一下线程池的实现过程

## 请简述一下线程池的运行流程，使用参数以及方法策略等

## 举例说明同步和异步

- 如果程序存在临界资源，例如正在写的数据可能被读到，或者正在读的数据可能被写，就应该对数据进行同步存取

- 当程序在执行方法时，如果需要很长的时间，但是不希望让程序等待方法返回时，可以使用异步

##  请问当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

- 不能，其他线程只能访问该对象的非同步方法，同步方法不能进入，因为非静态方法上的 synchronized 修饰符要求执行方法时获得对象的锁，如果一个线程已经进入到 A 之后说明它已经获取到了该对象的锁，另一个线程只能在 **等锁池** 等待

### 在项目的 controller 层使用同步是否合适

## 可重入锁

- 同一个线程对同一个对象是可重入的


## 请简短说明一下你对AQS的理解

- 

##  请简要说明一下JAVA中 cyclicbarrier 和 countdownlatch 的区别分别是什么

&emsp;&emsp;CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch 一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的

## 请分别说明一下多线程和同步有几种实现方法,并且这些实现方法具体内容都是什么？
`同步`、`多线程`
- **多线程：** 两种，继承 Thread 类，重写 run() 方法，或者实现 Runnable 接口，实现 run() 方法

- **同步：** synchronized  或者使用 wait 和 notify

## 请说出你所知道的线程同步的方法

- 

## 启动一个线程是用run()还是start()?
`线程`
- start()，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味
着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。

## 请简述一下线程的sleep()方法和yield()方法有什么区别？
`线程`
- sleep() 是 Thread 类的方法，可以使指定线程暂停执行指定的时间，把执行机会给其他线程，但是监控状态依然保持，到时间后会自动恢复，**调用 sleep() 不释放对象锁**

- wait() 是 Object 类的方法，对此对象调用 wait() 方法导致本线程放弃对象锁，进入等待对象的等待锁定池中，只有针对此对象发出 notifiy() 或者 notifiyAll 后，本线程才进入对象锁定池准备获取对象锁进入运行状态

## 请你说明一下在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？
`线程`、`同步`

- 监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码

## 请分析一下同步方法和同步代码块的区别是什么？
`同步`

- 同步方法，如果是非静态方法，锁的是 this，即调用方法的对象，如果是静态方法，调用的是这个类的 class 对象

- 同步代码块可以选择使用什么作锁，比同步方法有更细的粒度

## 线程的异常处理
<!-- TODO -->