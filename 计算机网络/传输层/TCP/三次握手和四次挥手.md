## 三次握手和四次挥手

&emsp;&emsp;一端叫 A，一端叫 B

## 三次握手过程

- 第一次：A 的请求建立连接，发送请求建立连接报文，SYN = 1，ACK = 0，seq = x。然后 A 进入到 SYN-SENT 阶段。

- 第二次：B 收到 A 的请求之后，如果同意建立连接，发送同意请求报文，SYN = 1，ACK = 1，ack = x+1。然后进入 SYN-RCVD 阶段。

- 第三次：A 收到 B 的同意之后，发送确认请求，ACK = 1，seq = x+1，ack = y+1。进入 established 阶段。等 B 收到 A 的确认之后进入 established 阶段。

### 为什么需要三次握手

&emsp;&emsp;为了防止已经失效的连接请求报文段到达客户端，因而发生错误。

&emsp;&emsp;正常情况：A 端发送连接请求，因为连接请求在网络中丢失了，B 并没有发送确认报文段，一段时间后 A 重传连接请求，B 接收到 A 的请求后发送确认，连接建立。

&emsp;&emsp;异常情况：A 发送连接请求，请求没有丢失而是在网络中滞留了，一段时间后没有接收到 B 的确认，A 又发送了一次连接请求，此次请求按时到达，然后 B 发送确认，连接建立。一段时间后 A 第一次发送的请求到达了 B 端，而 B 端又认为这个请求是 A 端发送的新的一个连接请求，于是又发送了确认，建立连接。这样就建立了两条连接，而只使用一条，造成了资源的浪费。

## 四次挥手

### 四次挥手过程

- 第一次：A 的应用进程先发送连接释放报文段，并停止再发送数据，主动关闭 TCP 连接，A 把连接释放报文段首部的终止位置 FIN 置1，序列号为 seq = u，等于前面发送的数据的最后一个字节的序号加 1，这时 A 进入 `FIN-WAIT-1` 阶段，等待 B 的确认。

- 第二次：B 收到 A 发送的连接释放报文后即发送确认报文，确认号是 u+1，自己的序列号是 v，v 是上次发送数据的最后一个字节的序列号加1，然后 B 进入 `CLOSE-WAIT` 阶段。这时 A 到 B 方向上连接就释放了，这时的 TCP 连接处于半关闭状态。  

    A 收到 B 发送的确认后，进入 `FIN-WAIT-2` 阶段，等待 B 发送连接释放请求

- 第三次：B 向 A 的发送数据也发送完毕了，B 就向 A 发送连接释放报文，FIN = 1，假设序列号 seq = w(可能在连接释放前，又发送了一些数据)，确认号还必须是 ack = u + 1(因为❓)。这时 B 进入 `LAST-ACK` 阶段，等待 A 的确认。

- 第四次：A 在收到 B 的连接释放请求之后，必须对 B 再发送确认，确认报文段 ACK = 1，确认号 ack = w+1，序列号 seq = u+1，然后进入 `TIME-WAIT` 阶段，然后等待**时间等待计时器**设置的时间 2MSL 后，A 进入 `CLOSED` 阶段。  

    B在收到确认之后，进入 `CLOSED` 阶段

### 为什么 A 端在 TIME-WAIT 阶段必须等待 2MSL 的时间呢

&emsp;&emsp;有两个原因

- 保证 A 端发送的最后一个 ACK 报文段到达 B 端。这个报文段可能丢失，因此使处于 `LAST-ACK` 阶段的 B 端收不到确认，B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，再次发送确认，重启 2MSL 计时器，最后 A 和 B 都正常进入 `CLOSED` 阶段。如果 A 在 `TIME-WAIT` 阶段不等待一段时间，而在发送完 ACK 报文段后立即进入 `CLOSED` 阶段，那么就无法收到 B 发送的 FIN+ACK 的重传，导致 B 无法进入 `CLOSED` 阶段

- 防止已失效的连接报文段出现在本连接中。A在发送完最后一个 ACK 报文段后，再经过 2MSL 时间，就可以使本连接持续时间内产生的所有报文段在网络中消失，这样就可以使下一个连接中不会出现旧的连接请求报文段

### MSL 是什么

&emsp;&emsp;MSL(Maximum Segment Lifetime) 叫做最长报文寿命，RFC 793设置为两分钟，但可以根据工程实际情况来考虑。

### 为什么需要四次挥手
