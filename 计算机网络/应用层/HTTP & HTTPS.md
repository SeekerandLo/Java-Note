## HTTP & HTTPS

`RTT Round-Trip Time`: 往返时延

## HTTP
&emsp;&emsp;HTTP协议定义了浏览器怎么向 web 服务器请求万维网文档，以及服务器怎么把文档发送给浏览器。

&emsp;&emsp;HTTP 使用了面向连接的 TCP 协议作为传输层协议，保证了数据的可靠传输。

### HTTP 1.0 和 HTTP 1.1 的区别

&emsp;&emsp;区别主要是 HTTP 1.1 支持持续连接，HTTP 1.0 每发送一个 HTTP 请求就要创建一条 TCP 连接。每从服务器端请求一个文件就要 2RTT 的时间。好在浏览器可以打开5~10个并行的 TCP 连接，每个连接处理一个请求。

&emsp;&emsp;HTTP 1.1 支持持续连接，打开一个网页，可以在一条 TCP 连接上连续发送 HTTP 请求。降低了资源消耗。持续连接有两种工作方式：
- 非流水线方式：客户在收到前一个的响应时才再次发送请求。

- 流水线方式：客户端在收到响应之前可以持续的发送请求，于是一个接一个的请求到达服务器端，服务器端可以连续的做出响应。

### HTTP 中 get 和 post 的区别

&emsp;&emsp;首先语义上的区别，get 是获取信息，post 是提交信息。

&emsp;&emsp;从 HTTP 规范看，GET用于信息获取，而且应该是安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一URL的多个请求应该返回同样的结果。POST表示可能修改变服务器上的资源的请求。

## HTTPS

### 非对称加密和对称加密的结合

- 某服务器有用于非对称加密的公钥 A，私钥 A'

- 浏览器向服务器发送请求，建立安全链接，服务器将公钥明文传输给浏览器

- 在浏览器端产生一个密钥X，使用公钥A加密。后发送给服务器端。

- 服务器端使用私钥 A' 解密，获取密钥X。

- 之后两端传输数据就使用密钥X加密。

### 中间人攻击

&emsp;&emsp;中间人的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A'解开拿到它呀！然而中间人却完全不需要拿到密钥A'就能干坏事了。

- 某服务器有公钥 A 和私钥 A'

- 浏览器向服务器请求建立安全链接，服务器发送公钥A给浏览器

- 🐱‍👤中间人在途中拦截了公钥A，中间人自己有公钥 B 和私钥 B'，在拦截了公钥 A 后，将自己的公钥 B 发送给浏览器

- 浏览器接收到公钥 B，然后生成一个密钥 X，使用公钥 B 加密，发送给服务器（浏览器不知道这个公钥 B 是谁的，它以为是服务器的）

- 🐱‍👤中间人拦截浏览器的请求，然后使用自己的私钥 B' 解密数据，获取密钥 X，然后再使用公钥 A 加密密钥 X，发送给服务器

- 服务器收到了，使用自己的私钥 A' 解密，获取密钥 X，之后的数据使用密钥 X 加密发送。但是此时密钥 X 已经泄露了。

### 证书 & 管理机构

&emsp;&emsp;为了解决上述问题，需要一个能证明是来自服务器的密钥的身份，这里引入证书的概念。证书表明了服务器的身份，当浏览器在收到证书之后去管理处查询，看是不是目标服务器，一查便知，中间人就无法再窃取了。

&emsp;&emsp;管理机构，CA（Certificate Authority） 机构，网站在使用 HTTPS 之前需要向 CA 机构申请一份数字证书 S，数字证书中包含证书的持有者，证书持有者的公钥，hash算法等信息，这些信息记为 I，服务器把证书发送给浏览器，浏览器检查证书，然后从证书中获取公钥。

&emsp;&emsp;**问题又来了，怎么防止证书被篡改？**

&emsp;&emsp;如果有中间人篡改了证书？如何保持证书的正确性，这里引入**数字签名**机制，把证书的内容生成一份签名 Q，比对证书内容 I hash后的结果和签名是否一致来判断是否被篡改。这里又使用到了非对称加密，不过使用方是 CA 证书管理机构。

&emsp;&emsp;**签名制作过程**
- CA 证书拥有非对称加密公钥和私钥

- CA 对证书内容 I 将进行 hash

- 然后使用私钥将 hash 值进行加密，得到一个数字签名 Q，一份数字证书就包含了数字签名 Q 和证书内容(服务器公钥，服务器信息) I

&emsp;&emsp;**浏览器验证过程**

- 浏览器拿到证书，得到数字签名和明文的证书内容

- 使用本地存储的 CA 公钥对证书进行解密，获取 hash 算法，证书内容 I，数字签名 Q

- 使用 hash 算法对证书内容进行 hash，对比数字签名和算出的结果，如果一致，则没有被篡改，如果不一致则不安全，终止通信

&emsp;&emsp;**浏览器/本地保存了 CA 证书的公钥**

&emsp;&emsp;操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。

### HTTPS 交换密钥的过程

- 浏览器向服务器发送安全请求

- 服务器给浏览器发送一个由 SSL 证书加密的数字证书，其中包含它的公钥

- 浏览器收到之后，使用本地的 SSL 证书对收到的数字证书进行解密，获取服务器的公钥

- 浏览器再用服务器的公钥加密一个接下来用于加密传输数据的密钥。传给服务器。

- 服务器使用私钥解密，获取密钥。

- 使用此密钥数据交流。

